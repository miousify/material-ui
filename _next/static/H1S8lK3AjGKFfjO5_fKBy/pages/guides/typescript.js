(window.webpackJsonp=window.webpackJsonp||[]).push([["f1c1"],{"2SP1":function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/guides/typescript",function(){var e=t("eavs");return{page:e.default||e}}])},"9E/z":function(e,n){e.exports="# TypeScript\n\n<p class=\"description\">Você pode adicionar tipagem estática para o JavaScript para melhorar a produtividade do desenvolvimento e a qualidade do código graças ao TypeScript.</p>\n\nDê uma olhada no exemplo [Create React App com TypeScript](https://github.com/mui-org/material-ui/tree/master/examples/create-react-app-with-typescript). É necessário estar no mínimo com a versão 2.8 do TypeScript.\n\nNossas definições são testadas com a seguinte configuração [tsconfig.json](https://github.com/mui-org/material-ui/tree/master/tsconfig.json). Usando uma `tsconfig.json` menos rigorosa ou omitindo algumas das bibliotecas podem causar erros.\n\n## Uso de `withStyles`\n\nUtilizando `withStyles` no TypeScript pode ser um pouco complicado, mas há alguns utilitários que tornam a experiência menos dolorosa possível.\n\n### Utilizando `createStyles` para evitar a ampliação de tipo (type widening)\n\nUma fonte frequente de confusão é a ampliação de tipos ([type widening](https://mariusschulz.com/blog/typescript-2-1-literal-type-widening)) do TypeScript, que faz com que este exemplo não funcione como o esperado:\n\n```ts\nconst styles = {\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  }\n};\n\nwithStyles(styles);\n//         ^^^^^^\n//         Os tipos de propriedade 'flexDirection' são incompatíveis.\n//           Tipo 'string' não pode ser atribuído para o tipo '\"-moz-initial\" | \"inherit\" | \"initial\" | \"revert\" | \"unset\" | \"column\" | \"column-reverse\" | \"row\"...'.\n```\n\nO problema é que o tipo da propriedade `flexDirection` é convertido como `string`, no qual é o tipo mais conveniente. Para corrigir isto, você pode passar o objeto de estilos diretamente para `withStyles`:\n\n```ts\nwithStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n```\n\nNo entanto, a ampliação de tipos continuará a causar dores de cabeça se você tentar fazer com que os estilos dependam do tema:\n\n```ts\nwithStyles(({ palette, spacing }) => ({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n}));\n```\n\nIsso ocorre pois o TypeScript [amplia o retorno de tipos de expressões de função](https://github.com/Microsoft/TypeScript/issues/241).\n\nPor causa disto, nós recomendamos utilizar nossa função auxiliar `createStyles` para construir seu objeto de regras de estilo:\n\n```ts\n// Estilos sem dependência\nconst styles = createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n\n// Estilos com dependência do tema\nconst styles = ({ palette, spacing }: Theme) => createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n});\n```\n\n`createStyles` é apenas a identidade da função; ela não \"faz nada\" em tempo de execução, apenas auxilia a inferência de tipos em tempo de compilação.\n\n### Consultas de Mídia (Media queries)\n\n`withStyles` permite utilizar um objeto de estilos de nível superior com consultas de mídia assim:\n\n```ts\nconst styles = createStyles({\n  root: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    root: {\n      display: 'flex',\n    },\n  },\n});\n```\n\nNo entanto, para permitir que estes estilos passem pelo TypeScript, as definições devem ser ambíguas em relação aos nomes de classes CSS e nomes de propriedades CSS. Devido a isso, evite utilizar nomes de classes iguais a propriedades do CSS.\n\n```ts\n// erro porque TypeScript acha que `@media (min-width: 960px)` é o nome da classe\n// e `content` é a propriedade css\nconst ambiguousStyles = createStyles({\n  content: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    content: {\n      display: 'flex',\n    },\n  },\n});\n\n// funciona corretamente\nconst ambiguousStyles = createStyles({\n  contentClass: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    contentClass: {\n      display: 'flex',\n    },\n  },\n});\n```\n\n### Incrementando suas propriedades utilizando `WithStyles`\n\nDesde que um componente seja decorado com `withStyles(styles)`, ele recebe uma propriedade injetada `classes`, você pode querer definir estas propriedades de acordo com:\n\n```ts\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props {\n  // non-style props\n  foo: number;\n  bar: boolean;\n  // injected style props\n  classes: {\n    root: string;\n    paper: string;\n    button: string;\n  };\n}\n```\n\nNo entanto isto não é muito elegante de acordo com o princípio de software [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself), porque requer que você mantenha os nomes das classes (`'root'`, `'paper'`, `'button'`, ...) em dois locais diferentes. Nós fornecemos um operador de tipo `WithStyles` para ajudar com isso, assim você pode apenas escrever:\n\n```ts\nimport { WithStyles, createStyles } from '@material-ui/core';\n\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props extends WithStyles<typeof styles> {\n  foo: number;\n  bar: boolean;\n}\n```\n\n### Decorando componentes\n\nAplicando `withStyles(styles)` como uma função, nos dá o resultado como o esperado:\n\n```tsx\nconst DecoratedSFC = withStyles(styles)(({ text, type, color, classes }: Props) => (\n  <Typography variant={type} color={color} classes={classes}>\n    {text}\n  </Typography>\n));\n\nconst DecoratedClass = withStyles(styles)(\n  class extends React.Component<Props> {\n    render() {\n      const { text, type, color, classes } = this.props\n      return (\n        <Typography variant={type} color={color} classes={classes}>\n          {text}\n        </Typography>\n      );\n    }\n  }\n);\n```\n\nInfelizmente devido a uma [limitação atual dos decoradores do TypeScript](https://github.com/Microsoft/TypeScript/issues/4881), `withStyles(styles)` não pode ser usado como decorador no TypeScript.\n\n## Customização de tema\n\nAo adicionar propriedades customizadas ao `Theme`, você pode continuar a utilizá-lo de uma maneira fortemente tipada, explorando o conceito de extensão de módulos do TypeScript ([TypeScript's module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation)).\n\nO exemplo a seguir adiciona uma propriedade `appDrawer` que é mesclada na que foi exportada pelo `material-ui`:\n\n```ts\nimport { Theme } from '@material-ui/core/styles/createMuiTheme';\nimport { Breakpoint } from '@material-ui/core/styles/createBreakpoints';\n\ndeclare module '@material-ui/core/styles/createMuiTheme' {\n  interface Theme {\n    appDrawer: {\n      width: React.CSSProperties['width']\n      breakpoint: Breakpoint\n    }\n  }\n  // permitir configuração usando `createMuiTheme`\n  interface ThemeOptions {\n    appDrawer?: {\n      width?: React.CSSProperties['width']\n      breakpoint?: Breakpoint\n    }\n  }\n}\n```\n\nE uma fábrica customizada de temas com opções padrão adicionais:\n\n**./styles/createMyTheme**:\n\n```ts\nimport createMuiTheme, { ThemeOptions } from '@material-ui/core/styles/createMuiTheme';\n\nexport default function createMyTheme(options: ThemeOptions) {\n  return createMuiTheme({\n    appDrawer: {\n      width: 225,\n      breakpoint: 'lg',\n    },\n    ...options,\n  })\n}\n```\n\nIsso poderia ser usado como:\n\n```ts\nimport createMyTheme from './styles/createMyTheme';\n\nconst theme = createMyTheme({ appDrawer: { breakpoint: 'md' }});\n```\n\n## Uso da propriedade `component`\n\nMaterial-UI permite que você substitua o nó raiz de um componente através de uma propriedade `component`. Por exemplo, a raiz de um componente `Button` pode ser substituída com um React Router `Link`, e quaisquer propriedades adicionais passadas para o `Button`, como `to`, será repassada para o componente `Link`. Para um exemplo de código relativo ao `Button` e `react-router-dom` verifique [esta demonstração](/components/buttons/#third-party-routing-library).\n\nNem todos os componentes suportam totalmente qualquer tipo de componente que você passe. Se você encontrar algum componente que rejeita sua propriedade `component` no TypeScript por favor abra um issue. Há um esforço contínuo para corrigir isso fazendo com que a propriedade component seja genérica.\n\n## Manipulando `value` e manipuladores de eventos\n\nMuitos componentes preocupados com a entrada do usuário oferecem uma propriedade `value` ou manipuladores de eventos que incluem o valor atual em `value`. Na maioria das situações, `value` só é manipulado dentro do React, o que permite que seja de qualquer tipo, como objetos ou matrizes.\n\nNo entanto, esse tipo não pode ser verificado em tempo de compilação em situações em que depende de nós filhos do componente, por exemplo, para `Select` ou `RadioGroup`. Isso significa que a opção mais segura é tipando como `unknown` e deixar que o desenvolvedor decida como deseja restringir esse tipo. Não oferecemos a possibilidade de usar um tipo genérico nesses casos, devido [as mesmas razões que `event.target` não é genérico no React](https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508#issuecomment-256045682).\n\nNossas demonstrações incluem variantes tipadas que usam conversão de tipo. É uma troca aceitável porque os tipos estão todos localizados em um único arquivo e são muito básicos. Você tem que decidir por si mesmo se a mesma troca é aceitável para você. Queremos que a nossa biblioteca de tipos seja estrita por padrão e livre através de opt-in."},"L+bY":function(e,n){e.exports="# TypeScript\n\n<p class=\"description\">TypeScriptを使用することで、JavaScriptに静的型付けを追加し、開発者の生産性とコード品質を向上させることができます。</p>\n\n[Create React AppでのTypeScript](https://github.com/mui-org/material-ui/tree/master/examples/create-react-app-with-typescript)の使用例を参考にしてください。 TypeScript 2.8以上が必要です。\n\n私たちの定義は、こちらの[tsconfig.json](https://github.com/mui-org/material-ui/tree/master/tsconfig.json) でテストしています。 あまり厳密でない`tsconfig.json`を使ったり、一部のライブラリを省略した場合、エラーが発生する可能性があります。\n\n## `withStyles`の使い方\n\n`withStyles`をTypeScriptで使うのは少し厄介ですが、それをできるだけ簡単に扱うためのユーティリティがいくつかあります。\n\n### `createStyles`を使って型の拡大を打倒する\n\nよくある混乱の原因は、TypeScriptの[型の拡大(widening)](https://mariusschulz.com/blog/typescript-2-1-literal-type-widening)です。これにより、この例は期待通りに動作しません。\n\n```ts\nconst styles = {\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  }\n};\n\nwithStyles(styles);\n//         ^^^^^^\n//         Types of property 'flexDirection' are incompatible.\n//           Type 'string' is not assignable to type '\"-moz-initial\" | \"inherit\" | \"initial\" | \"revert\" | \"unset\" | \"column\" | \"column-reverse\" | \"row\"...'.\n```\n\n問題は、`flexDirection`プロパティの型が`string`として型推論されることです。これは独断的すぎます。 これを修正するため、styleオブジェクトを直接`withStyles`に渡します:\n\n```ts\nwithStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n```\n\nHowever type widening rears its ugly head once more if you try to make the styles depend on the theme:\n\n```ts\nwithStyles(({ palette, spacing }) => ({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n}));\n```\n\nThis is because TypeScript [widens the return types of function expressions](https://github.com/Microsoft/TypeScript/issues/241).\n\nBecause of this, we recommend using our `createStyles` helper function to construct your style rules object:\n\n```ts\n// Non-dependent styles\nconst styles = createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n\n// Theme-dependent styles\nconst styles = ({ palette, spacing }: Theme) => createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n});\n```\n\n`createStyles` is just the identity function; it doesn't \"do anything\" at runtime, just helps guide type inference at compile time.\n\n### Media queries\n\n`withStyles` allows a styles object with top level media-queries like so:\n\n```ts\nconst styles = createStyles({\n  root: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    root: {\n      display: 'flex',\n    },\n  },\n});\n```\n\nHowever to allow these styles to pass TypeScript, the definitions have to be ambiguous concerning names for CSS classes and actual CSS property names. Due to this class names that are equal to CSS properties should be avoided.\n\n```ts\n// error because TypeScript thinks `@media (min-width: 960px)` is a class name\n// and `content` is the css property\nconst ambiguousStyles = createStyles({\n  content: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    content: {\n      display: 'flex',\n    },\n  },\n});\n\n// works just fine\nconst ambiguousStyles = createStyles({\n  contentClass: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    contentClass: {\n      display: 'flex',\n    },\n  },\n});\n```\n\n### Augmenting your props using `WithStyles`\n\nSince a component decorated with `withStyles(styles)` gets a special `classes` prop injected, you will want to define its props accordingly:\n\n```ts\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props {\n  // non-style props\n  foo: number;\n  bar: boolean;\n  // injected style props\n  classes: {\n    root: string;\n    paper: string;\n    button: string;\n  };\n}\n```\n\nHowever this isn't very [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) because it requires you to maintain the class names (`'root'`, `'paper'`, `'button'`, ...) in two different places. We provide a type operator `WithStyles` to help with this, so that you can just write:\n\n```ts\nimport { WithStyles, createStyles } from '@material-ui/core';\n\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props extends WithStyles<typeof styles> {\n  foo: number;\n  bar: boolean;\n}\n```\n\n### Decorating components\n\nApplying `withStyles(styles)` as a function works as expected:\n\n```tsx\nconst DecoratedSFC = withStyles(styles)(({ text, type, color, classes }: Props) => (\n  <Typography variant={type} color={color} classes={classes}>\n    {text}\n  </Typography>\n));\n\nconst DecoratedClass = withStyles(styles)(\n  class extends React.Component<Props> {\n    render() {\n      const { text, type, color, classes } = this.props\n      return (\n        <Typography variant={type} color={color} classes={classes}>\n          {text}\n        </Typography>\n      );\n    }\n  }\n);\n```\n\nUnfortunately due to a [current limitation of TypeScript decorators](https://github.com/Microsoft/TypeScript/issues/4881), `withStyles(styles)` can't be used as a decorator in TypeScript.\n\n## Customization of `Theme`\n\nWhen adding custom properties to the `Theme`, you may continue to use it in a strongly typed way by exploiting [TypeScript's module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation).\n\nThe following example adds an `appDrawer` property that is merged into the one exported by `material-ui`:\n\n```ts\nimport { Theme } from '@material-ui/core/styles/createMuiTheme';\nimport { Breakpoint } from '@material-ui/core/styles/createBreakpoints';\n\ndeclare module '@material-ui/core/styles/createMuiTheme' {\n  interface Theme {\n    appDrawer: {\n      width: React.CSSProperties['width']\n      breakpoint: Breakpoint\n    }\n  }\n  // allow configuration using `createMuiTheme`\n  interface ThemeOptions {\n    appDrawer?: {\n      width?: React.CSSProperties['width']\n      breakpoint?: Breakpoint\n    }\n  }\n}\n```\n\nAnd a custom theme factory with additional defaulted options:\n\n**./styles/createMyTheme**:\n\n```ts\nimport createMuiTheme, { ThemeOptions } from '@material-ui/core/styles/createMuiTheme';\n\nexport default function createMyTheme(options: ThemeOptions) {\n  return createMuiTheme({\n    appDrawer: {\n      width: 225,\n      breakpoint: 'lg',\n    },\n    ...options,\n  })\n}\n```\n\nThis could be used like:\n\n```ts\nimport createMyTheme from './styles/createMyTheme';\n\nconst theme = createMyTheme({ appDrawer: { breakpoint: 'md' }});\n```\n\n## Usage of `component` property\n\nMaterial-UI allows you to replace a component's root node via a `component` property. For example, a `Button`'s root node can be replaced with a React Router `Link`, and any additional props that are passed to `Button`, such as `to`, will be spread to the `Link` component. For a code example concerning `Button` and `react-router-dom` checkout [this Button demo](/components/buttons/#third-party-routing-library).\n\nNot every component fully supports any component type you pass in. If you encounter a component that rejects its `component` props in TypeScript please open an issue. There is an ongoing effort to fix this by making component props generic.\n\n## Handling `value` and event handlers\n\nMany components concerned with user input offer a `value` prop or event handlers which include the current `value`. In most situations that `value` is only handled within React which allows it be of any type, such as objects or arrays.\n\nHowever, that type cannot be verified at compile time in situations where it depends on the component's children e.g. for `Select` or `RadioGroup`. This means that the soundest option is to type it as `unknown` and let the developer decide how they want to narrow that type down. We do not offer the possibility to use a generic type in those cases for [the same reasons `event.target` is not generic in React](https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508#issuecomment-256045682).\n\nOur demos include typed variants that use type casting. It is an acceptable tradeoff because the types are all located in a single file and are very basic. You have to decide for yourself if the same tradeoff is acceptable for you. We want our library types to be strict by default and loose via opt-in."},"L/Rt":function(e,n){e.exports="# TypeScript\n\n<p class=\"description\">You can add static typing to JavaScript to improve developer productivity and code quality thanks to TypeScript.</p>\n\nHave a look at the [Create React App with TypeScript](https://github.com/mui-org/material-ui/tree/master/examples/create-react-app-with-typescript) example. A minimum version of TypeScript 2.8 is required.\n\nOur definitions are tested with the following [tsconfig.json](https://github.com/mui-org/material-ui/tree/master/tsconfig.json). Using a less strict `tsconfig.json` or omitting some of the libraries might cause errors.\n\n## Usage of `withStyles`\n\nUsing `withStyles` in TypeScript can be a little tricky, but there are some utilities to make the experience as painless as possible.\n\n### Using `createStyles` to defeat type widening\n\nA frequent source of confusion is TypeScript's [type widening](https://mariusschulz.com/blog/typescript-2-1-literal-type-widening), which causes this example not to work as expected:\n\n```ts\nconst styles = {\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  }\n};\n\nwithStyles(styles);\n//         ^^^^^^\n//         Types of property 'flexDirection' are incompatible.\n//           Type 'string' is not assignable to type '\"-moz-initial\" | \"inherit\" | \"initial\" | \"revert\" | \"unset\" | \"column\" | \"column-reverse\" | \"row\"...'.\n```\n\nThe problem is that the type of the `flexDirection` property is inferred as `string`, which is too arbitrary. To fix this, you can pass the styles object directly to `withStyles`:\n\n```ts\nwithStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n```\n\nHowever type widening rears its ugly head once more if you try to make the styles depend on the theme:\n\n```ts\nwithStyles(({ palette, spacing }) => ({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n}));\n```\n\nThis is because TypeScript [widens the return types of function expressions](https://github.com/Microsoft/TypeScript/issues/241).\n\nBecause of this, we recommend using our `createStyles` helper function to construct your style rules object:\n\n```ts\n// Non-dependent styles\nconst styles = createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n\n// Theme-dependent styles\nconst styles = ({ palette, spacing }: Theme) => createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n});\n```\n\n`createStyles` is just the identity function; it doesn't \"do anything\" at runtime, just helps guide type inference at compile time.\n\n### Media queries\n\n`withStyles` allows a styles object with top level media-queries like so:\n\n```ts\nconst styles = createStyles({\n  root: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    root: {\n      display: 'flex',\n    },\n  },\n});\n```\n\nHowever to allow these styles to pass TypeScript, the definitions have to be ambiguous concerning names for CSS classes and actual CSS property names. Due to this class names that are equal to CSS properties should be avoided.\n\n```ts\n// error because TypeScript thinks `@media (min-width: 960px)` is a class name\n// and `content` is the css property\nconst ambiguousStyles = createStyles({\n  content: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    content: {\n      display: 'flex',\n    },\n  },\n});\n\n// works just fine\nconst ambiguousStyles = createStyles({\n  contentClass: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    contentClass: {\n      display: 'flex',\n    },\n  },\n});\n```\n\n### Augmenting your props using `WithStyles`\n\nSince a component decorated with `withStyles(styles)` gets a special `classes` prop injected, you will want to define its props accordingly:\n\n```ts\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props {\n  // non-style props\n  foo: number;\n  bar: boolean;\n  // injected style props\n  classes: {\n    root: string;\n    paper: string;\n    button: string;\n  };\n}\n```\n\nHowever this isn't very [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) because it requires you to maintain the class names (`'root'`, `'paper'`, `'button'`, ...) in two different places. We provide a type operator `WithStyles` to help with this, so that you can just write:\n\n```ts\nimport { WithStyles, createStyles } from '@material-ui/core';\n\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props extends WithStyles<typeof styles> {\n  foo: number;\n  bar: boolean;\n}\n```\n\n### Decorating components\n\nApplying `withStyles(styles)` as a function works as expected:\n\n```tsx\nconst DecoratedSFC = withStyles(styles)(({ text, type, color, classes }: Props) => (\n  <Typography variant={type} color={color} classes={classes}>\n    {text}\n  </Typography>\n));\n\nconst DecoratedClass = withStyles(styles)(\n  class extends React.Component<Props> {\n    render() {\n      const { text, type, color, classes } = this.props\n      return (\n        <Typography variant={type} color={color} classes={classes}>\n          {text}\n        </Typography>\n      );\n    }\n  }\n);\n```\n\nUnfortunately due to a [current limitation of TypeScript decorators](https://github.com/Microsoft/TypeScript/issues/4881), `withStyles(styles)` can't be used as a decorator in TypeScript.\n\n## Customization of `Theme`\n\nWhen adding custom properties to the `Theme`, you may continue to use it in a strongly typed way by exploiting [TypeScript's module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation).\n\nThe following example adds an `appDrawer` property that is merged into the one exported by `material-ui`:\n\n```ts\nimport { Theme } from '@material-ui/core/styles/createMuiTheme';\nimport { Breakpoint } from '@material-ui/core/styles/createBreakpoints';\n\ndeclare module '@material-ui/core/styles/createMuiTheme' {\n  interface Theme {\n    appDrawer: {\n      width: React.CSSProperties['width']\n      breakpoint: Breakpoint\n    }\n  }\n  // allow configuration using `createMuiTheme`\n  interface ThemeOptions {\n    appDrawer?: {\n      width?: React.CSSProperties['width']\n      breakpoint?: Breakpoint\n    }\n  }\n}\n```\n\nAnd a custom theme factory with additional defaulted options:\n\n**./styles/createMyTheme**:\n\n```ts\nimport createMuiTheme, { ThemeOptions } from '@material-ui/core/styles/createMuiTheme';\n\nexport default function createMyTheme(options: ThemeOptions) {\n  return createMuiTheme({\n    appDrawer: {\n      width: 225,\n      breakpoint: 'lg',\n    },\n    ...options,\n  })\n}\n```\n\nThis could be used like:\n\n```ts\nimport createMyTheme from './styles/createMyTheme';\n\nconst theme = createMyTheme({ appDrawer: { breakpoint: 'md' }});\n```\n\n## Usage of `component` property\n\nMaterial-UI allows you to replace a component's root node via a `component` property. For example, a `Button`'s root node can be replaced with a React Router `Link`, and any additional props that are passed to `Button`, such as `to`, will be spread to the `Link` component. For a code example concerning `Button` and `react-router-dom` checkout [this Button demo](/components/buttons/#third-party-routing-library).\n\nNot every component fully supports any component type you pass in. If you encounter a component that rejects its `component` props in TypeScript please open an issue. There is an ongoing effort to fix this by making component props generic.\n\n## Handling `value` and event handlers\n\nMany components concerned with user input offer a `value` prop or event handlers which include the current `value`. In most situations that `value` is only handled within React which allows it be of any type, such as objects or arrays.\n\nHowever, that type cannot be verified at compile time in situations where it depends on the component's children e.g. for `Select` or `RadioGroup`. This means that the soundest option is to type it as `unknown` and let the developer decide how they want to narrow that type down. We do not offer the possibility to use a generic type in those cases for [the same reasons `event.target` is not generic in React](https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508#issuecomment-256045682).\n\nOur demos include typed variants that use type casting. It is an acceptable tradeoff because the types are all located in a single file and are very basic. You have to decide for yourself if the same tradeoff is acceptable for you. We want our library types to be strict by default and loose via opt-in."},LaJE:function(e,n){e.exports="# TypeScript\n\n<p class=\"description\">借助 TypeScript，你可以为 JavaScript 添加静态类型，从而提高代码质量及开发者的工作效率。</p>\n\n请查看一下 [Create React App with TypeScript](https://github.com/mui-org/material-ui/tree/master/examples/create-react-app-with-typescript) 的例子。 我们要求 TypeScript 版本必须大于 2.8。\n\n我们的定义都通过 [tsconfig.json](https://github.com/mui-org/material-ui/tree/master/tsconfig.json) 进行测试。 使用不太严格的 `tsconfig.json` 或省略某些库可能会带来一些错误。\n\n## `withStyles` 的使用\n\n在 TypeScript 中使用 `withStyles` 可能有点棘手，但有一些实用程序可以帮助提高使用感受。\n\n### 使用 `createStyles` 来杜绝类型扩展\n\n有一个造成混淆的常见原因是 TypeScript的 [类型扩展](https://mariusschulz.com/blog/typescript-2-1-literal-type-widening)，因此这个示例不会像预期那样工作：\n\n```ts\nconst styles = {\n  root： {\n    display: 'flex',\n    flexDirection: 'column',\n  }\n};\n\nwithStyles（styles）;\n//         ^^^^^^\n//        属性 'flexDirection' 的类型是不兼容的。\n//           'string' 类型不能赋予给这些类型：'\"-moz-initial\" | \"inherit\" | \"initial\" | \"revert\" | \"unset\" | \"column\" | \"column-reverse\" | \"row\"...'。\n```\n\n问题是 `flexDirection` 属性的类型被推断为 `string`，这样太随意了。 要解决此问题，您可以将样式对象直接传递给 `withStyles`：\n\n```ts\nwithStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n```\n\n然而，如果您尝试让样式随主题而变化，类型扩展会再次显示其不怎么雅观的部分：\n\n```ts\nwithStyles(({ palette, spacing }) => ({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n}));\n```\n\n这是因为 TypeScript [扩展了函数表达式](https://github.com/Microsoft/TypeScript/issues/241)的返回类型。\n\n因此，我们建议使用我们的 `createStyles` 帮助函数来构造样式规则对象：\n\n```ts\n// 不依赖于主题的样式\nconst styles = createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n\n// 依赖于主题的样式\nconst styles = ({ palette, spacing }: Theme) => createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n});\n```\n\n`createStyles` 只是身份函数；它不会在运行时“做任何事情”，只是在编译时指导类型推断。\n\n### Media queries（媒体查询）\n\n`withStyles` 允许样式对象具有顶级媒体查询的权限，如下所示：\n\n```ts\nconst styles = createStyles({\n  root: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    root: {\n      display: 'flex',\n    },\n  },\n});\n```\n\n但是，为了允许这些样式传递 TypeScript，鉴于CSS 类的名称和实际的 CSS 属性名称不一致，定义必须是模糊的。 由于类名称应与 CSS 属性相同，因此应避免使用。\n\n```ts\n// 这样是错误的，由于 TypeScript 认为 `@media (min-width: 960px)` 是一个类名\n// 并且 `content` 是 css 属性\nconst ambiguousStyles = createStyles({\n  content: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    content: {\n      display: 'flex',\n    },\n  },\n});\n\n// 这样定义就可以\nconst ambiguousStyles = createStyles({\n  contentClass: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    contentClass: {\n      display: 'flex',\n    },\n  },\n});\n```\n\n### 使用 `WithStyles` 来扩充你的属性\n\n由于用 `withStyles(styles)` 装饰的组件被注入了一个特殊的 `classes` 属性，您需要相应地定义其属性：\n\n```ts\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props {\n  // 未被注入样式的属性\n  foo: number;\n  bar: boolean;\n  // 被注入样式的属性\n  classes: {\n    root: string;\n    paper: string;\n    button: string;\n  };\n}\n```\n\n然而，这是不是很 [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) ，因为它需要你在两个不同的地方保持类名（`'root'`， `'paper'`， `'button'`，...）。 我们提供了一个类型操作符 `WithStyles` 来帮助解决这个问题，因此您可以直接写入：:\n\n```ts\nimport { WithStyles, createStyles } from '@material-ui/core';\n\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props extends WithStyles<typeof styles> {\n  foo: number;\n  bar: boolean;\n}\n```\n\n### 装饰组件\n\n将 `withStyles(styles)` 作为函数来如期使用：\n\n```tsx\nconst DecoratedSFC = withStyles(styles)(({ text, type, color, classes }: Props) => (\n  <Typography variant={type} color={color} classes={classes}>\n    {text}\n  </Typography>\n));\n\nconst DecoratedClass = withStyles(styles)(\n  class extends React.Component<Props> {\n    render() {\n      const { text, type, color, classes } = this.props\n      return (\n        <Typography variant={type} color={color} classes={classes}>\n          {text}\n        </Typography>\n      );\n    }\n  }\n);\n```\n\n不幸的是，由于[TypeScript 装饰器现有的限制 ](https://github.com/Microsoft/TypeScript/issues/4881)， `withStyles(styles)` 不能用在 TypeScript 中作为一个装饰器。\n\n## 自定义 `主题`\n\n将自定义属性添加到`主题`中时，您可以通过以强类型的方式实现 [TypeScript 的模块扩充](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation)而继续使用它 。\n\n以下示例添加了一个 `appDrawer` 属性，并将其合并到由 `material-ui` 提供的属性中：\n\n```ts\nimport { Theme } from '@material-ui/core/styles/createMuiTheme';\nimport { Breakpoint } from '@material-ui/core/styles/createBreakpoints';\n\ndeclare module '@material-ui/core/styles/createMuiTheme' {\n  interface Theme {\n    appDrawer: {\n      width: React.CSSProperties['width']\n      breakpoint: Breakpoint\n    }\n  }\n  // 使用 `createMuiTheme` 来配置\n  interface ThemeOptions {\n    appDrawer?: {\n      width?: React.CSSProperties['width']\n      breakpoint?: Breakpoint\n    }\n  }\n}\n```\n\n以及一个带有其他默认选项的自定义主题仓库：\n\n**./styles/createMyTheme**:\n\n```ts\nimport createMuiTheme, { ThemeOptions } from '@material-ui/core/styles/createMuiTheme';\n\nexport default function createMyTheme(options: ThemeOptions) {\n  return createMuiTheme({\n    appDrawer: {\n      width: 225,\n      breakpoint: 'lg',\n    },\n    ...options,\n  })\n}\n```\n\n也可以这样使用：\n\n```ts\nimport createMyTheme from './styles/createMyTheme';\n\nconst theme = createMyTheme({ appDrawer: { breakpoint: 'md' }});\n```\n\n## `组件`属性的用法\n\n在 Material-UI 中，您可以用`组件`的属性来替换一个组件的根节点。 譬如，一个 `Button` 的根节点可以用一个 React Router 的`Link`来替换，而且 `Button` 的其余属性，例如 `to`，也可以运用到 `Link` 组件当中。 若您想查看 `Button` 以及 `react-router-dom` 的例子，请查看 [this Button demo](/components/buttons/#third-party-routing-library)。\n\n但是，并不是每个组件都完全支持您传入的任何组件类型。 如果您在 TypeScript 中遇到一个不接受其 `component` 属性的组件，请新建一个 issue。 我们也一直在努力实现组件属性的通用化， 这样能够帮助我们解决这个问题。\n\n## 处理`值`和事件处理器\n\n很多与用户输入有关的组件会提供一个 `value` 属性或者包含当前`值`的事件处理器。 大多数情况下`值`只在 React 内被处理，这样的话它能够是任何类型，譬如 objects 或者 arrays。\n\n然而，如果是它依赖于组件子项的情况，此类型无法在编译时被验证，例如对于 `Select` 或者 `RadioGroup` 来说。 这意味着留给我们的最合适的选项是将其输入为 `unknown` 并让开发者自行决定如何来缩小该类型。 与 [`event.target` 在 React 中并不通用的原因](https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508#issuecomment-256045682)相同，我们并不推荐您在这些案例中尝试使用一个通用的类型。\n\n我们的演示包含了使用类型转换的类型变体。 鉴于所有的类型都位于一个文件中，并且都是非常基本的，这样的折衷可以接受。 您必须自行决定是否能够接受同样的折衷。 我们则希望，通过选择性加入，我们的库的类型默认为严格的。"},NZiB:function(e,n){function t(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}t.keys=function(){return[]},t.resolve=t,e.exports=t,t.id="NZiB"},RvGA:function(e,n){e.exports="# crwdns96734:0crwdne96734:0\n\n<p class=\"description\">crwdns96736:0crwdne96736:0</p>\n\ncrwdns96738:0crwdne96738:0 crwdns96740:0crwdne96740:0\n\ncrwdns96742:0crwdne96742:0 crwdns96744:0crwdne96744:0\n\n## crwdns96746:0crwdne96746:0\n\ncrwdns96748:0crwdne96748:0\n\n### crwdns96750:0crwdne96750:0\n\ncrwdns96752:0crwdne96752:0\n\n```ts\ncrwdns96754:0{\n    display: 'flex',\n    flexDirection: 'column',\n  }crwdne96754:0\ncrwdns96756:0crwdne96756:0\n```\n\ncrwdns96758:0crwdne96758:0 crwdns96760:0crwdne96760:0\n\n```ts\ncrwdns96762:0{\n    display: 'flex',\n    flexDirection: 'column',\n  }crwdne96762:0\n```\n\ncrwdns96764:0crwdne96764:0\n\n```ts\ncrwdns96766:0{ palette, spacing }crwdne96766:0\n```\n\ncrwdns96768:0crwdne96768:0\n\ncrwdns96770:0crwdne96770:0\n\n```ts\ncrwdns96772:0{\n    display: 'flex',\n    flexDirection: 'column',\n  }crwdnd96772:0{ palette, spacing }crwdne96772:0\n```\n\ncrwdns96774:0crwdne96774:0\n\n### crwdns96776:0crwdne96776:0\n\ncrwdns96778:0crwdne96778:0\n\n```ts\ncrwdns96780:0{\n    minHeight: '100vh',\n  }crwdnd96780:0{\n      display: 'flex',\n    }crwdne96780:0\n```\n\ncrwdns96782:0crwdne96782:0 crwdns96784:0crwdne96784:0\n\n```ts\ncrwdns96786:0{\n    minHeight: '100vh',\n  }crwdnd96786:0{\n      display: 'flex',\n    }crwdnd96786:0{\n    minHeight: '100vh',\n  }crwdnd96786:0{\n      display: 'flex',\n    }crwdne96786:0\n```\n\n### crwdns96788:0crwdne96788:0\n\ncrwdns96790:0crwdne96790:0\n\n```ts\ncrwdns96792:0crwdne96792:0 crwdns96794:0crwdne96794:0 crwdns96796:0crwdne96796:0 crwdns96798:0crwdne96798:0\n```\n\ncrwdns96800:0%27crwdne96800:0 crwdns96802:0crwdne96802:0\n\n```ts\ncrwdns96804:0{ WithStyles, createStyles }crwdne96804:0 crwdns96806:0crwdne96806:0 crwdns96808:0crwdne96808:0 crwdns96810:0crwdne96810:0\n```\n\n### crwdns96812:0crwdne96812:0\n\ncrwdns96814:0crwdne96814:0\n\n```tsx\ncrwdns96816:0{type}crwdnd96816:0{color}crwdnd96816:0{classes}crwdnd96816:0{text}crwdnd96816:0{type}crwdnd96816:0{color}crwdnd96816:0{classes}crwdnd96816:0{text}crwdne96816:0\n```\n\ncrwdns96818:0crwdne96818:0\n\n## crwdns96820:0crwdne96820:0\n\ncrwdns96822:0crwdne96822:0\n\ncrwdns96824:0crwdne96824:0\n\n```ts\ncrwdns96826:0{ Theme }crwdnd96826:0{ Breakpoint }crwdne96826:0\n```\n\ncrwdns96828:0crwdne96828:0\n\ncrwdns96830:0crwdne96830:0\n\n```ts\ncrwdns96832:0{ ThemeOptions }crwdnd96832:0{\n      width: 225,\n      breakpoint: 'lg',\n    }crwdne96832:0\n```\n\ncrwdns96834:0crwdne96834:0\n\n```ts\ncrwdns96836:0{ breakpoint: 'md' }crwdne96836:0\n```\n\n## crwdns96838:0crwdne96838:0\n\ncrwdns96840:0crwdne96840:0 crwdns96842:0crwdne96842:0 crwdns96844:0crwdne96844:0\n\ncrwdns96846:0crwdne96846:0 crwdns96848:0crwdne96848:0 crwdns96850:0crwdne96850:0\n\n## crwdns96852:0crwdne96852:0\n\ncrwdns96854:0crwdne96854:0 crwdns96856:0crwdne96856:0\n\ncrwdns96858:0crwdne96858:0 crwdns96860:0crwdne96860:0 crwdns96862:0crwdne96862:0\n\ncrwdns96864:0crwdne96864:0 crwdns96866:0crwdne96866:0 crwdns96868:0crwdne96868:0 crwdns96870:0crwdne96870:0"},TGHD:function(e,n){e.exports="# TypeScript\n\n<p class=\"description\">You can add static typing to JavaScript to improve developer productivity and code quality thanks to TypeScript.</p>\n\nHave a look at the [Create React App with TypeScript](https://github.com/mui-org/material-ui/tree/master/examples/create-react-app-with-typescript) example. A minimum version of TypeScript 2.8 is required.\n\nOur definitions are tested with the following [tsconfig.json](https://github.com/mui-org/material-ui/tree/master/tsconfig.json).\nUsing a less strict `tsconfig.json` or omitting some of the libraries might cause errors.\n\n## Usage of `withStyles`\n\nUsing `withStyles` in TypeScript can be a little tricky, but there are some utilities to make the experience as painless as possible.\n\n### Using `createStyles` to defeat type widening\n\nA frequent source of confusion is TypeScript's [type widening](https://mariusschulz.com/blog/typescript-2-1-literal-type-widening), which causes this example not to work as expected:\n\n```ts\nconst styles = {\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  }\n};\n\nwithStyles(styles);\n//         ^^^^^^\n//         Types of property 'flexDirection' are incompatible.\n//           Type 'string' is not assignable to type '\"-moz-initial\" | \"inherit\" | \"initial\" | \"revert\" | \"unset\" | \"column\" | \"column-reverse\" | \"row\"...'.\n```\n\nThe problem is that the type of the `flexDirection` property is inferred as `string`, which is too arbitrary. To fix this, you can pass the styles object directly to `withStyles`:\n\n```ts\nwithStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n```\n\nHowever type widening rears its ugly head once more if you try to make the styles depend on the theme:\n\n```ts\nwithStyles(({ palette, spacing }) => ({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n}));\n```\n\nThis is because TypeScript [widens the return types of function expressions](https://github.com/Microsoft/TypeScript/issues/241).\n\nBecause of this, we recommend using our `createStyles` helper function to construct your style rules object:\n\n```ts\n// Non-dependent styles\nconst styles = createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n\n// Theme-dependent styles\nconst styles = ({ palette, spacing }: Theme) => createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n});\n```\n\n`createStyles` is just the identity function; it doesn't \"do anything\" at runtime, just helps guide type inference at compile time.\n\n### Media queries\n\n`withStyles` allows a styles object with top level media-queries like so:\n\n```ts\nconst styles = createStyles({\n  root: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    root: {\n      display: 'flex',\n    },\n  },\n});\n```\n\nHowever to allow these styles to pass TypeScript, the definitions have to be ambiguous concerning names for CSS classes and actual CSS property names. Due to this class names that are equal to CSS properties should be avoided.\n\n```ts\n// error because TypeScript thinks `@media (min-width: 960px)` is a class name\n// and `content` is the css property\nconst ambiguousStyles = createStyles({\n  content: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    content: {\n      display: 'flex',\n    },\n  },\n});\n\n// works just fine\nconst ambiguousStyles = createStyles({\n  contentClass: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    contentClass: {\n      display: 'flex',\n    },\n  },\n});\n```\n\n### Augmenting your props using `WithStyles`\n\nSince a component decorated with `withStyles(styles)` gets a special `classes` prop injected, you will want to define its props accordingly:\n\n```ts\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props {\n  // non-style props\n  foo: number;\n  bar: boolean;\n  // injected style props\n  classes: {\n    root: string;\n    paper: string;\n    button: string;\n  };\n}\n```\n\nHowever this isn't very [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) because it requires you to maintain the class names (`'root'`, `'paper'`, `'button'`, ...) in two different places. We provide a type operator `WithStyles` to help with this, so that you can just write:\n\n```ts\nimport { WithStyles, createStyles } from '@material-ui/core';\n\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props extends WithStyles<typeof styles> {\n  foo: number;\n  bar: boolean;\n}\n```\n\n### Decorating components\n\nApplying `withStyles(styles)` as a function works as expected:\n\n```tsx\nconst DecoratedSFC = withStyles(styles)(({ text, type, color, classes }: Props) => (\n  <Typography variant={type} color={color} classes={classes}>\n    {text}\n  </Typography>\n));\n\nconst DecoratedClass = withStyles(styles)(\n  class extends React.Component<Props> {\n    render() {\n      const { text, type, color, classes } = this.props\n      return (\n        <Typography variant={type} color={color} classes={classes}>\n          {text}\n        </Typography>\n      );\n    }\n  }\n);\n```\n\nUnfortunately due to a [current limitation of TypeScript decorators](https://github.com/Microsoft/TypeScript/issues/4881), `withStyles(styles)` can't be used as a decorator in TypeScript.\n\n## Customization of `Theme`\n\nWhen adding custom properties to the `Theme`, you may continue to use it in a strongly typed way by exploiting\n[TypeScript's module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation).\n\nThe following example adds an `appDrawer` property that is merged into the one exported by `material-ui`:\n\n```ts\nimport { Theme } from '@material-ui/core/styles/createMuiTheme';\nimport { Breakpoint } from '@material-ui/core/styles/createBreakpoints';\n\ndeclare module '@material-ui/core/styles/createMuiTheme' {\n  interface Theme {\n    appDrawer: {\n      width: React.CSSProperties['width']\n      breakpoint: Breakpoint\n    }\n  }\n  // allow configuration using `createMuiTheme`\n  interface ThemeOptions {\n    appDrawer?: {\n      width?: React.CSSProperties['width']\n      breakpoint?: Breakpoint\n    }\n  }\n}\n```\n\nAnd a custom theme factory with additional defaulted options:\n\n**./styles/createMyTheme**:\n```ts\nimport createMuiTheme, { ThemeOptions } from '@material-ui/core/styles/createMuiTheme';\n\nexport default function createMyTheme(options: ThemeOptions) {\n  return createMuiTheme({\n    appDrawer: {\n      width: 225,\n      breakpoint: 'lg',\n    },\n    ...options,\n  })\n}\n```\n\nThis could be used like:\n\n```ts\nimport createMyTheme from './styles/createMyTheme';\n\nconst theme = createMyTheme({ appDrawer: { breakpoint: 'md' }});\n```\n\n## Usage of `component` property\nMaterial-UI allows you to replace a component's root node via a `component` property.\nFor example, a `Button`'s root node can be replaced with a React Router `Link`, and any additional props that are passed to `Button`, such as `to`, will be spread to the `Link` component. For a code\nexample concerning `Button` and `react-router-dom` checkout [this Button demo](/components/buttons/#third-party-routing-library).\n\nNot every component fully supports any component type you pass in. If you encounter a\ncomponent that rejects its `component` props in TypeScript please open an issue.\nThere is an ongoing effort to fix this by making component props generic.\n\n## Handling `value` and event handlers\n\nMany components concerned with user input offer a `value` prop or event handlers\nwhich include the current `value`. In most situations that `value` is only handled\nwithin React which allows it be of any type, such as objects or arrays.\n\nHowever, that type cannot be verified at compile time in situations where it depends\non the component's children e.g. for `Select` or `RadioGroup`. This means that\nthe soundest option is to type it as `unknown` and let the developer decide\nhow they want to narrow that type down. We do not offer the possibility to use a generic\ntype in those cases for [the same reasons `event.target` is not generic in React](https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508#issuecomment-256045682).\n\nOur demos include typed variants that use type casting. It is an acceptable tradeoff\nbecause the types are all located in a single file and are very basic. You have to decide for yourself\nif the same tradeoff is acceptable for you. We want our library types to be strict\nby default and loose via opt-in.\n"},VzWm:function(e,n){e.exports="# TypeScript\n\n<p class=\"description\">Vous pouvez ajouter du typage statique à JavaScript pour améliorer la productivité des développeurs et la qualité du code grâce à TypeScript.</p>\n\nHave a look at the [Create React App with TypeScript](https://github.com/mui-org/material-ui/tree/master/examples/create-react-app-with-typescript) example. Une version minimale de TypeScript 2.8 est requise.\n\nOur definitions are tested with the following [tsconfig.json](https://github.com/mui-org/material-ui/tree/master/tsconfig.json). Using a less strict `tsconfig.json` or omitting some of the libraries might cause errors.\n\n## Usage of `withStyles`\n\nUsing `withStyles` in TypeScript can be a little tricky, but there are some utilities to make the experience as painless as possible.\n\n### Using `createStyles` to defeat type widening\n\nA frequent source of confusion is TypeScript's [type widening](https://mariusschulz.com/blog/typescript-2-1-literal-type-widening), which causes this example not to work as expected:\n\n```ts\nconst styles = {\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  }\n};\n\nwithStyles(styles);\n//         ^^^^^^\n//         Types of property 'flexDirection' are incompatible.\n//           Type 'string' is not assignable to type '\"-moz-initial\" | \"inherit\" | \"initial\" | \"revert\" | \"unset\" | \"column\" | \"column-reverse\" | \"row\"...'.\n```\n\nThe problem is that the type of the `flexDirection` property is inferred as `string`, which is too arbitrary. To fix this, you can pass the styles object directly to `withStyles`:\n\n```ts\nwithStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n```\n\nHowever type widening rears its ugly head once more if you try to make the styles depend on the theme:\n\n```ts\nwithStyles(({ palette, spacing }) => ({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n}));\n```\n\nThis is because TypeScript [widens the return types of function expressions](https://github.com/Microsoft/TypeScript/issues/241).\n\nBecause of this, we recommend using our `createStyles` helper function to construct your style rules object:\n\n```ts\n// Non-dependent styles\nconst styles = createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n\n// Theme-dependent styles\nconst styles = ({ palette, spacing }: Theme) => createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n});\n```\n\n`createStyles` is just the identity function; it doesn't \"do anything\" at runtime, just helps guide type inference at compile time.\n\n### Media queries\n\n`withStyles` allows a styles object with top level media-queries like so:\n\n```ts\nconst styles = createStyles({\n  root: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    root: {\n      display: 'flex',\n    },\n  },\n});\n```\n\nHowever to allow these styles to pass TypeScript, the definitions have to be ambiguous concerning names for CSS classes and actual CSS property names. Due to this class names that are equal to CSS properties should be avoided.\n\n```ts\n// error because TypeScript thinks `@media (min-width: 960px)` is a class name\n// and `content` is the css property\nconst ambiguousStyles = createStyles({\n  content: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    content: {\n      display: 'flex',\n    },\n  },\n});\n\n// works just fine\nconst ambiguousStyles = createStyles({\n  contentClass: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    contentClass: {\n      display: 'flex',\n    },\n  },\n});\n```\n\n### Augmenting your props using `WithStyles`\n\nSince a component decorated with `withStyles(styles)` gets a special `classes` prop injected, you will want to define its props accordingly:\n\n```ts\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props {\n  // non-style props\n  foo: number;\n  bar: boolean;\n  // injected style props\n  classes: {\n    root: string;\n    paper: string;\n    button: string;\n  };\n}\n```\n\nHowever this isn't very [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) because it requires you to maintain the class names (`'root'`, `'paper'`, `'button'`, ...) in two different places. We provide a type operator `WithStyles` to help with this, so that you can just write:\n\n```ts\nimport { WithStyles, createStyles } from '@material-ui/core';\n\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props extends WithStyles<typeof styles> {\n  foo: number;\n  bar: boolean;\n}\n```\n\n### Decorating components\n\nApplying `withStyles(styles)` as a function works as expected:\n\n```tsx\nconst DecoratedSFC = withStyles(styles)(({ text, type, color, classes }: Props) => (\n  <Typography variant={type} color={color} classes={classes}>\n    {text}\n  </Typography>\n));\n\nconst DecoratedClass = withStyles(styles)(\n  class extends React.Component<Props> {\n    render() {\n      const { text, type, color, classes } = this.props\n      return (\n        <Typography variant={type} color={color} classes={classes}>\n          {text}\n        </Typography>\n      );\n    }\n  }\n);\n```\n\nUnfortunately due to a [current limitation of TypeScript decorators](https://github.com/Microsoft/TypeScript/issues/4881), `withStyles(styles)` can't be used as a decorator in TypeScript.\n\n## Customization of `Theme`\n\nWhen adding custom properties to the `Theme`, you may continue to use it in a strongly typed way by exploiting [TypeScript's module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation).\n\nThe following example adds an `appDrawer` property that is merged into the one exported by `material-ui`:\n\n```ts\nimport { Theme } from '@material-ui/core/styles/createMuiTheme';\nimport { Breakpoint } from '@material-ui/core/styles/createBreakpoints';\n\ndeclare module '@material-ui/core/styles/createMuiTheme' {\n  interface Theme {\n    appDrawer: {\n      width: React.CSSProperties['width']\n      breakpoint: Breakpoint\n    }\n  }\n  // allow configuration using `createMuiTheme`\n  interface ThemeOptions {\n    appDrawer?: {\n      width?: React.CSSProperties['width']\n      breakpoint?: Breakpoint\n    }\n  }\n}\n```\n\nAnd a custom theme factory with additional defaulted options:\n\n**./styles/createMyTheme**:\n\n```ts\nimport createMuiTheme, { ThemeOptions } from '@material-ui/core/styles/createMuiTheme';\n\nexport default function createMyTheme(options: ThemeOptions) {\n  return createMuiTheme({\n    appDrawer: {\n      width: 225,\n      breakpoint: 'lg',\n    },\n    ...options,\n  })\n}\n```\n\nThis could be used like:\n\n```ts\nimport createMyTheme from './styles/createMyTheme';\n\nconst theme = createMyTheme({ appDrawer: { breakpoint: 'md' }});\n```\n\n## Usage of `component` property\n\nMaterial-UI allows you to replace a component's root node via a `component` property. For example, a `Button`'s root node can be replaced with a React Router `Link`, and any additional props that are passed to `Button`, such as `to`, will be spread to the `Link` component. For a code example concerning `Button` and `react-router-dom` checkout [this Button demo](/components/buttons/#third-party-routing-library).\n\nNot every component fully supports any component type you pass in. If you encounter a component that rejects its `component` props in TypeScript please open an issue. There is an ongoing effort to fix this by making component props generic.\n\n## Handling `value` and event handlers\n\nMany components concerned with user input offer a `value` prop or event handlers which include the current `value`. In most situations that `value` is only handled within React which allows it be of any type, such as objects or arrays.\n\nHowever, that type cannot be verified at compile time in situations where it depends on the component's children e.g. for `Select` or `RadioGroup`. This means that the soundest option is to type it as `unknown` and let the developer decide how they want to narrow that type down. We do not offer the possibility to use a generic type in those cases for [the same reasons `event.target` is not generic in React](https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508#issuecomment-256045682).\n\nOur demos include typed variants that use type casting. It is an acceptable tradeoff because the types are all located in a single file and are very basic. You have to decide for yourself if the same tradeoff is acceptable for you. We want our library types to be strict by default and loose via opt-in."},eavs:function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return p});var o=t("mXGw"),s=t.n(o),i=t("e+1t"),r=t("yQL/"),a=t("NZiB"),c=s.a.createElement(i.a,{req:r,reqSource:a,reqPrefix:"pages/guides/typescript"});function p(){return c}},"ns/w":function(e,n){e.exports="# TypeScript\n\n<p class=\"description\">You can add static typing to JavaScript to improve developer productivity and code quality thanks to TypeScript.</p>\n\nHave a look at the [Create React App with TypeScript](https://github.com/mui-org/material-ui/tree/master/examples/create-react-app-with-typescript) example. A minimum version of TypeScript 2.8 is required.\n\nOur definitions are tested with the following [tsconfig.json](https://github.com/mui-org/material-ui/tree/master/tsconfig.json). Using a less strict `tsconfig.json` or omitting some of the libraries might cause errors.\n\n## Usage of `withStyles`\n\nUsing `withStyles` in TypeScript can be a little tricky, but there are some utilities to make the experience as painless as possible.\n\n### Using `createStyles` to defeat type widening\n\nA frequent source of confusion is TypeScript's [type widening](https://mariusschulz.com/blog/typescript-2-1-literal-type-widening), which causes this example not to work as expected:\n\n```ts\nconst styles = {\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  }\n};\n\nwithStyles(styles);\n//         ^^^^^^\n//         Types of property 'flexDirection' are incompatible.\n//           Type 'string' is not assignable to type '\"-moz-initial\" | \"inherit\" | \"initial\" | \"revert\" | \"unset\" | \"column\" | \"column-reverse\" | \"row\"...'.\n```\n\nThe problem is that the type of the `flexDirection` property is inferred as `string`, which is too arbitrary. To fix this, you can pass the styles object directly to `withStyles`:\n\n```ts\nwithStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n```\n\nHowever type widening rears its ugly head once more if you try to make the styles depend on the theme:\n\n```ts\nwithStyles(({ palette, spacing }) => ({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n}));\n```\n\nThis is because TypeScript [widens the return types of function expressions](https://github.com/Microsoft/TypeScript/issues/241).\n\nBecause of this, we recommend using our `createStyles` helper function to construct your style rules object:\n\n```ts\n// Non-dependent styles\nconst styles = createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n\n// Theme-dependent styles\nconst styles = ({ palette, spacing }: Theme) => createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n});\n```\n\n`createStyles` is just the identity function; it doesn't \"do anything\" at runtime, just helps guide type inference at compile time.\n\n### Media queries\n\n`withStyles` allows a styles object with top level media-queries like so:\n\n```ts\nconst styles = createStyles({\n  root: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    root: {\n      display: 'flex',\n    },\n  },\n});\n```\n\nHowever to allow these styles to pass TypeScript, the definitions have to be ambiguous concerning names for CSS classes and actual CSS property names. Due to this class names that are equal to CSS properties should be avoided.\n\n```ts\n// error because TypeScript thinks `@media (min-width: 960px)` is a class name\n// and `content` is the css property\nconst ambiguousStyles = createStyles({\n  content: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    content: {\n      display: 'flex',\n    },\n  },\n});\n\n// works just fine\nconst ambiguousStyles = createStyles({\n  contentClass: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    contentClass: {\n      display: 'flex',\n    },\n  },\n});\n```\n\n### Augmenting your props using `WithStyles`\n\nSince a component decorated with `withStyles(styles)` gets a special `classes` prop injected, you will want to define its props accordingly:\n\n```ts\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props {\n  // non-style props\n  foo: number;\n  bar: boolean;\n  // injected style props\n  classes: {\n    root: string;\n    paper: string;\n    button: string;\n  };\n}\n```\n\nHowever this isn't very [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) because it requires you to maintain the class names (`'root'`, `'paper'`, `'button'`, ...) in two different places. We provide a type operator `WithStyles` to help with this, so that you can just write:\n\n```ts\nimport { WithStyles, createStyles } from '@material-ui/core';\n\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props extends WithStyles<typeof styles> {\n  foo: number;\n  bar: boolean;\n}\n```\n\n### Decorating components\n\nApplying `withStyles(styles)` as a function works as expected:\n\n```tsx\nconst DecoratedSFC = withStyles(styles)(({ text, type, color, classes }: Props) => (\n  <Typography variant={type} color={color} classes={classes}>\n    {text}\n  </Typography>\n));\n\nconst DecoratedClass = withStyles(styles)(\n  class extends React.Component<Props> {\n    render() {\n      const { text, type, color, classes } = this.props\n      return (\n        <Typography variant={type} color={color} classes={classes}>\n          {text}\n        </Typography>\n      );\n    }\n  }\n);\n```\n\nUnfortunately due to a [current limitation of TypeScript decorators](https://github.com/Microsoft/TypeScript/issues/4881), `withStyles(styles)` can't be used as a decorator in TypeScript.\n\n## Customization of `Theme`\n\nWhen adding custom properties to the `Theme`, you may continue to use it in a strongly typed way by exploiting [TypeScript's module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation).\n\nThe following example adds an `appDrawer` property that is merged into the one exported by `material-ui`:\n\n```ts\nimport { Theme } from '@material-ui/core/styles/createMuiTheme';\nimport { Breakpoint } from '@material-ui/core/styles/createBreakpoints';\n\ndeclare module '@material-ui/core/styles/createMuiTheme' {\n  interface Theme {\n    appDrawer: {\n      width: React.CSSProperties['width']\n      breakpoint: Breakpoint\n    }\n  }\n  // allow configuration using `createMuiTheme`\n  interface ThemeOptions {\n    appDrawer?: {\n      width?: React.CSSProperties['width']\n      breakpoint?: Breakpoint\n    }\n  }\n}\n```\n\nAnd a custom theme factory with additional defaulted options:\n\n**./styles/createMyTheme**:\n\n```ts\nimport createMuiTheme, { ThemeOptions } from '@material-ui/core/styles/createMuiTheme';\n\nexport default function createMyTheme(options: ThemeOptions) {\n  return createMuiTheme({\n    appDrawer: {\n      width: 225,\n      breakpoint: 'lg',\n    },\n    ...options,\n  })\n}\n```\n\nThis could be used like:\n\n```ts\nimport createMyTheme from './styles/createMyTheme';\n\nconst theme = createMyTheme({ appDrawer: { breakpoint: 'md' }});\n```\n\n## Usage of `component` property\n\nMaterial-UI allows you to replace a component's root node via a `component` property. For example, a `Button`'s root node can be replaced with a React Router `Link`, and any additional props that are passed to `Button`, such as `to`, will be spread to the `Link` component. For a code example concerning `Button` and `react-router-dom` checkout [this Button demo](/components/buttons/#third-party-routing-library).\n\nNot every component fully supports any component type you pass in. If you encounter a component that rejects its `component` props in TypeScript please open an issue. There is an ongoing effort to fix this by making component props generic.\n\n## Handling `value` and event handlers\n\nMany components concerned with user input offer a `value` prop or event handlers which include the current `value`. In most situations that `value` is only handled within React which allows it be of any type, such as objects or arrays.\n\nHowever, that type cannot be verified at compile time in situations where it depends on the component's children e.g. for `Select` or `RadioGroup`. This means that the soundest option is to type it as `unknown` and let the developer decide how they want to narrow that type down. We do not offer the possibility to use a generic type in those cases for [the same reasons `event.target` is not generic in React](https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508#issuecomment-256045682).\n\nOur demos include typed variants that use type casting. It is an acceptable tradeoff because the types are all located in a single file and are very basic. You have to decide for yourself if the same tradeoff is acceptable for you. We want our library types to be strict by default and loose via opt-in."},uEgI:function(e,n){e.exports="# TypeScript\n\n<p class=\"description\">Sie können statische Typisierung zu JavaScript hinzufügen, um die Produktivität und die Codequalität dank TypeScript zu verbessern.</p>\n\nSchauen Sie sich das [Create React App mit TypeScript](https://github.com/mui-org/material-ui/tree/master/examples/create-react-app-with-typescript) Beispiel an. Eine Mindestversion von TypeScript 2.8 ist erforderlich.\n\nUnsere Type Definitionen werden mit der folgenden [tsconfig.json](https://github.com/mui-org/material-ui/tree/master/tsconfig.json) getestet. Verwendung einer weniger strengen `tsconfig.json` oder das Weglassen einiger Bibliotheken kann zu Fehlern führen.\n\n## Verwendung von `withStyles`\n\nVerwenden von `withStyles` in TypeScript kann es etwas kniffelig sein, aber es gibt einige Hilfsprogramme, um die Erfahrung so schmerzlos wie möglich zu gestalten.\n\n### Verwenden von `CreateStyles`, um die Typerweiterung zu besiegen\n\nEine häufige Quelle der Verwirrung ist die [Erweiterung der Typen](https://mariusschulz.com/blog/typescript-2-1-literal-type-widening) von TypeScript, was dazu führt, dass dieses Beispiel nicht wie erwartet funktioniert:\n\n```ts\nconst styles = {\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  }\n};\n\nwithStyles(styles);\n//         ^^^^^^\n//         Typen der Eigenschaft  'flexDirection' sind nicht kompatibel.\n// Der Typ 'string' kann dem Typ '\"-moz-initial\" | \"inherit\" | \"initial\" |\n// \"revert\" | \"unset\" | \"column\" | \"column-reverse\" | \"row\"...'\n// nicht zugewiesen werden.\n```\n\nDas Problem ist, dass der Typ der `flexDirection` als `string` interpretiert wird, was zu ungenau ist. Um dies zu beheben, können Sie das Styles-Objekt direkt an `withStyles`: übergeben:\n\n```ts\nwithStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n```\n\nWenn Sie jedoch versuchen, die Stile von dem Thema abhängig zu machen, macht Ihnen die Typenerweiterung wieder eine Strich durch die Rechnung:\n\n```ts\nwithStyles(({ palette, spacing }) => ({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n}));\n```\n\nDies liegt daran, dass TypeScript [die Rückgabetypen von Funktionsausdrücken ](https://github.com/Microsoft/TypeScript/issues/241) erweitert.\n\nAus diesem Grund empfehlen wir die Verwendung unserer `createStyles` Hilfsfunktion zum Erstellen Ihres Stilregelobjekts:\n\n```ts\n// Non-dependent styles\nconst styles = createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n\n// Theme-dependent styles\nconst styles = ({ palette, spacing }: Theme) => createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n});\n```\n\n`createStyles` ist nur die Identitätsfunktion; es \"tut\" nichts zur Laufzeit, es hilft nur die Typen zur Kompilierzeit festzulegen.\n\n### Media-Anfragen\n\n`withStyles` erlaubt ein Styles-Objekt mit Top-Level-Media-Abfragen wie:\n\n```ts\nconst styles = createStyles({\n  root: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    root: {\n      display: 'flex',\n    },\n  },\n});\n```\n\nDamit diese Stile an TypeScript übergeben werden können, müssen die Definitionen hinsichtlich der Namen der CSS-Klassen und der tatsächlichen CSS-Eigenschaftsnamen mehrdeutig sein. Aus diesem Grund sollten Klassennamen, die den CSS-Eigenschaften entsprechen, vermieden werden.\n\n```ts\n// Fehler, da TypeScript denkte, dass `@media (min-width: 960px)` ein Klassen-\n// name und `content` eine css Eigenschaft ist\nconst ambiguousStyles = createStyles({\n  content: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    content: {\n      display: 'flex',\n    },\n  },\n});\n\n// Dies funktioniert\nconst ambiguousStyles = createStyles({\n  contentClass: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    contentClass: {\n      display: 'flex',\n    },\n  },\n});\n```\n\n### Erweitern Sie Ihre Eigenschaften mit `WithStyles`\n\nDa, wenn eine Komponente mit `withStyles(styles)` dekoriert ist, eine spezielle `classes` Eigenschaft injiziert bekommt, möchten Sie die Eigenschaften entsprechend definieren:\n\n```ts\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props {\n  // Nicht style Eigenschaften\n  foo: number;\n  bar: boolean;\n  // Injizierte Style Eigenschaften\n  classes: {\n    root: string;\n    paper: string;\n    button: string;\n  };\n}\n```\n\nDies ist jedoch nicht sehr [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) weil Sie die Klassennamen (`'root'`, `'paper'`, `'button'`, ...) an zwei verschiedenen Stellen pflegen müssen. Wir stellen einen Typoperator `WithStyles` bereit, um damit zu helfen. So kannst du einfach schreiben:\n\n```ts\nimport { WithStyles, createStyles } from '@material-ui/core';\n\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props extends WithStyles<typeof styles> {\n  foo: number;\n  bar: boolean;\n}\n```\n\n### Komponenten dekorieren\n\nAnwenden von `withStyles(styles)` als Funktion funktioniert wie erwartet:\n\n```tsx\nconst DecoratedSFC = withStyles(styles)(({ text, type, color, classes }: Props) => (\n  <Typography variant={type} color={color} classes={classes}>\n    {text}\n  </Typography>\n));\n\nconst DecoratedClass = withStyles(styles)(\n  class extends React.Component<Props> {\n    render() {\n      const { text, type, color, classes } = this.props\n      return (\n        <Typography variant={type} color={color} classes={classes}>\n          {text}\n        </Typography>\n      );\n    }\n  }\n);\n```\n\nAufgrund einer [aktuellen Einschränkung der TypeScript-Dekorateure](https://github.com/Microsoft/TypeScript/issues/4881), kann `withStyles(styles)` leider nicht als Dekorator in TypeScript verwendet werden.\n\n## Anpassung des `Theme`\n\nBeim Hinzufügen benutzerdefinierter Eigenschaften zum `Theme` können Sie es weiterhin in stark typisierter Weise verwenden, indem Sie die [Modulerweiterung von TypeScript](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation) nutzen.\n\nIm folgenden Beispiel wird eine `appDrawer` Eigenschaft hinzugefügt, welche in das von `material-ui` exportierte Theme eingefügt wird:\n\n```ts\nimport { Theme } from '@material-ui/core/styles/createMuiTheme';\nimport { Breakpoint } from '@material-ui/core/styles/createBreakpoints';\n\ndeclare module '@material-ui/core/styles/createMuiTheme' {\n  interface Theme {\n    appDrawer: {\n      width: React.CSSProperties['width']\n      breakpoint: Breakpoint\n    }\n  }\n  // allow configuration using `createMuiTheme`\n  interface ThemeOptions {\n    appDrawer?: {\n      width?: React.CSSProperties['width']\n      breakpoint?: Breakpoint\n    }\n  }\n}\n```\n\nUnd eine benutzerdefinierte Theme Generierung mit zusätzlichen Standardoptionen:\n\n**./styles/createMyTheme**:\n\n```ts\nimport createMuiTheme, { ThemeOptions } from '@material-ui/core/styles/createMuiTheme';\n\nexport default function createMyTheme(options: ThemeOptions) {\n  return createMuiTheme({\n    appDrawer: {\n      width: 225,\n      breakpoint: 'lg',\n    },\n    ...options,\n  })\n}\n```\n\nDies könnte wie folgt verwendet werden:\n\n```ts\nimport createMyTheme from './styles/createMyTheme';\n\nconst theme = createMyTheme({ appDrawer: { breakpoint: 'md' }});\n```\n\n## Verwendung der `component` Eigenschaft\n\nMit der Material-UI können Sie die root Komponente einer Komponente durch die `component` Eigenschaft ersetzen. Zum Beispiel ist die Stamm Komponente eines `Button` durch einen React Router `Link` ersetzt werden und alle zusätzlichen Eigenschaften, die an den `Button` übergeben werden, wie `to`, wird auf die `Link` Komponente verteilt. Für ein Code Beispiel für den `Button ` und `react-router-dom` schau dir [diese Demo an](/components/buttons/#third-party-routing-library).\n\nNicht jede Komponente unterstützt vollständig jeden übergebenen Komponententyp. Wenn Sie auf eine Komponente stoßen, die ihre `component` Eigenschaft ablehnt in TypeScript, öffnen Sie bitte eine Frage in Github. Es besteht ein ständiger Aufwand, um dies zu beheben, indem Komponentenstützen generisch gemacht werden.\n\n## Handling `value` and event handlers\n\nMany components concerned with user input offer a `value` prop or event handlers which include the current `value`. In most situations that `value` is only handled within React which allows it be of any type, such as objects or arrays.\n\nHowever, that type cannot be verified at compile time in situations where it depends on the component's children e.g. for `Select` or `RadioGroup`. This means that the soundest option is to type it as `unknown` and let the developer decide how they want to narrow that type down. We do not offer the possibility to use a generic type in those cases for [the same reasons `event.target` is not generic in React](https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508#issuecomment-256045682).\n\nOur demos include typed variants that use type casting. It is an acceptable tradeoff because the types are all located in a single file and are very basic. You have to decide for yourself if the same tradeoff is acceptable for you. We want our library types to be strict by default and loose via opt-in."},"yQL/":function(e,n,t){var o={"./typescript-aa.md":"RvGA","./typescript-de.md":"uEgI","./typescript-es.md":"ns/w","./typescript-fr.md":"VzWm","./typescript-ja.md":"L+bY","./typescript-pt.md":"9E/z","./typescript-ru.md":"L/Rt","./typescript-zh.md":"LaJE","./typescript.md":"TGHD"};function s(e){var n=i(e);return t(n)}function i(e){var n=o[e];if(!(n+1)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return n}s.keys=function(){return Object.keys(o)},s.resolve=i,e.exports=s,s.id="yQL/"}},[["2SP1","5d41","9da1"]]]);