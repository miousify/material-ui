(window.webpackJsonp=window.webpackJsonp||[]).push([["3600"],{"0wvg":function(e,n){e.exports="# API Design Approach\n\n<p class=\"description\">Nós aprendemos bastante como o Material-UI é usado e o refatoramento da v1 permitiu-nos repensar completamente o componente de API.</p>\n\n> API design is hard because you can make it seem simple but it's actually deceptively complex, or make it actually simple but seem complex.\n\n[@sebmarkbage](https://twitter.com/sebmarkbage/status/728433349337841665)\n\nAs Sebastian Markbage [pointed out](https://2014.jsconf.eu/speakers/sebastian-markbage-minimal-api-surface-area-learning-patterns-instead-of-frameworks.html), no abstraction is superior to wrong abstractions. We are providing low-level components to maximize composition capabilities.\n\n## Composition\n\nYou may have noticed some inconsistency in the API regarding composing components. To provide some transparency, we have been using the following rules when designing the API:\n\n1. Using the `children` property is the idiomatic way to do composition with React.\n2. Sometimes we only need limited child composition, for instance when we don't need to allow child order permutations. In this case, providing explicit properties makes the implementation simpler and more performant; for example, the `Tab` takes an `icon` and a `label` property.\n3. API consistency matters.\n\n## Rules\n\nAside from the above composition trade-off, we enforce the following rules:\n\n### Spread\n\nUndocumented properties supplied are spread to the root element; for instance, the `className` property is applied to the root.\n\nNow, let's say you want to disable the ripples on the `MenuItem`. You can take advantage of the spread behavior:\n\n```jsx\n<MenuItem disableRipple />\n```\n\nThe `disableRipple` property will flow this way: [`MenuItem`](/api/menu-item/) > [`ListItem`](/api/list-item/) > [`ButtonBase`](/api/button-base/).\n\n### Native properties\n\nWe avoid documenting native properties supported by the DOM like [`className`](/customization/components/#overriding-styles-with-class-names).\n\n### CSS Classes\n\nAll the components accept a [`classes`](/customization/components/#overriding-styles-with-classes) property to customize the styles. The classes design answers two constraints: to make the classes structure as simple as possible, while sufficient to implement the Material Design specification.\n\n- The class applied to the root element is always called `root`.\n- All the default styles are grouped in a single class.\n- The classes applied to non-root elements are prefixed with the name of the element, e.g. `paperWidthXs` in the Dialog component.\n- The variants applied by a boolean property **aren't** prefixed, e.g. the `rounded` class applied by the `rounded` property.\n- The variants applied by an enum property **are** prefixed, e.g. the `colorPrimary` class applied by the `color=\"primary\"` property.\n- A variant has **one level of specificity**. The `color` and `variant` properties are considered a variant. The lower the style specificity is, the simpler it is to override.\n- We increase the specificity for a variant modifier. We already **have to do it** for the pseudo-classes (`:hover`, `:focus`, etc.). It allows much more control at the cost of more boilerplate. Hopefully, it's also more intuitive.\n\n```js\nconst styles = {\n  root: {\n    color: green[600],\n    '&$checked': {\n      color: green[500],\n    },\n  },\n  checked: {},\n};\n```\n\n### Nested components\n\nNested components inside a component have:\n\n- their own flattened properties when these are key to the top level component abstraction, for instance and `id` property for the `Input` component.\n- their own `xxxProps` property when users might need to tweak the internal render method's sub-components, for instance, exposing the `inputProps` and `InputProps` properties on components that use `Input` internally.\n- their own `xxxComponent` property for performing component injection.\n- their own `xxxRef` property when user might need to perform imperative actions, for instance, exposing a `inputRef` property to access the native `input` on the `Input` component. This helps answer the question [\"How can I access the DOM element?\"](/getting-started/faq/#how-can-i-access-the-dom-element)\n\n### Property naming\n\nThe name of a boolean property should be chosen based on the **default value**. For example, the `disabled` attribute on an input element, if supplied, defaults to `true`. This choice allows the shorthand notation:\n\n```diff\n-<Input enabled={false} />\n+<Input disabled />\n```\n\n### Controlled components\n\nMost of the controlled component are controlled via the `value` and the `onChange` properties, however, the `open` / `onClose` / `onOpen` combination is used for display related state.\n\n### boolean vs enum\n\nThere are two options to design the API for the variations of a component: with a *boolean*; or with an *enum*. For example, let's take a button that has different types. Each option has its pros and cons:\n\n- Option 1 *boolean*:\n    \n    ```tsx\n    type Props = {\n    contained: boolean;\n    fab: boolean;\n    };\n    ```\n    \n    This API enabled the shorthand notation: `<Button>`, `<Button contained />`, `<Button fab />`.\n\n- Option 2 *enum*:\n    \n    ```tsx\n    type Props = {\n      variant: 'text' | 'contained' | 'fab';\n    }\n    ```\n    \n    This API is more verbose: `<Button>`, `<Button variant=\"contained\">`, `<Button variant=\"fab\">`.\n    \n    However it prevents an invalid combination from being used, bounds the number of properties exposed, and can easily support new values in the future.\n\nThe Material-UI components use a combination of the two approaches according to the following rules:\n\n- A *boolean* is used when **2** degrees of freedom are required.\n- An *enum* is used when **> 2** degrees of freedom are required, or if there is the possibility that additional degrees of freedom may be required in the future.\n\nGoing back to the previous button example; since it requires 3 degrees of freedom, we use an *enum*.\n\n### Ref\n\nThe `ref` is forwarded to the root element. This means that, without changing the rendered root element via the `component` prop, it is forwarded to the outermost DOM element that which component renders. If you pass a different component via the `component` prop the ref will be attached to that component instead.\n\n## Словарь\n\n- **host component**: a DOM node type in the context of `react-dom`, e.g. a `'div'`. См. также [React Implementation Notes:](https://reactjs.org/docs/implementation-notes.html#mounting-host-elements).\n- **host element**: DOM-нода в контексте `react-dom`, т.е. экземляр `window.HTMLDivElement`.\n- **outermost**: The first component when reading the component tree from top to bottom i.e. breadth-first search.\n- **root component**: the outermost component that renders a host component.\n- **root element**: the outermost element that renders a host component."},"2iYb":function(e,n){e.exports="# API Design Approach\n\n<p class=\"description\">Nós aprendemos bastante como o Material-UI é usado e o refatoramento da v1 permitiu-nos repensar completamente o componente de API.</p>\n\n> API design is hard because you can make it seem simple but it's actually deceptively complex, or make it actually simple but seem complex.\n\n[@sebmarkbage](https://twitter.com/sebmarkbage/status/728433349337841665)\n\nAs Sebastian Markbage [pointed out](https://2014.jsconf.eu/speakers/sebastian-markbage-minimal-api-surface-area-learning-patterns-instead-of-frameworks.html), no abstraction is superior to wrong abstractions. We are providing low-level components to maximize composition capabilities.\n\n## Composition\n\nYou may have noticed some inconsistency in the API regarding composing components. To provide some transparency, we have been using the following rules when designing the API:\n\n1. Using the `children` property is the idiomatic way to do composition with React.\n2. Sometimes we only need limited child composition, for instance when we don't need to allow child order permutations. In this case, providing explicit properties makes the implementation simpler and more performant; for example, the `Tab` takes an `icon` and a `label` property.\n3. API consistency matters.\n\n## Rules\n\nAside from the above composition trade-off, we enforce the following rules:\n\n### Spread\n\nUndocumented properties supplied are spread to the root element; for instance, the `className` property is applied to the root.\n\nNow, let's say you want to disable the ripples on the `MenuItem`. You can take advantage of the spread behavior:\n\n```jsx\n<MenuItem disableRipple />\n```\n\nThe `disableRipple` property will flow this way: [`MenuItem`](/api/menu-item/) > [`ListItem`](/api/list-item/) > [`ButtonBase`](/api/button-base/).\n\n### Native properties\n\nWe avoid documenting native properties supported by the DOM like [`className`](/customization/components/#overriding-styles-with-class-names).\n\n### CSS Classes\n\nAll the components accept a [`classes`](/customization/components/#overriding-styles-with-classes) property to customize the styles. The classes design answers two constraints: to make the classes structure as simple as possible, while sufficient to implement the Material Design specification.\n\n- The class applied to the root element is always called `root`.\n- All the default styles are grouped in a single class.\n- The classes applied to non-root elements are prefixed with the name of the element, e.g. `paperWidthXs` in the Dialog component.\n- The variants applied by a boolean property **aren't** prefixed, e.g. the `rounded` class applied by the `rounded` property.\n- The variants applied by an enum property **are** prefixed, e.g. the `colorPrimary` class applied by the `color=\"primary\"` property.\n- A variant has **one level of specificity**. The `color` and `variant` properties are considered a variant. The lower the style specificity is, the simpler it is to override.\n- We increase the specificity for a variant modifier. We already **have to do it** for the pseudo-classes (`:hover`, `:focus`, etc.). It allows much more control at the cost of more boilerplate. Hopefully, it's also more intuitive.\n\n```js\nconst styles = {\n  root: {\n    color: green[600],\n    '&$checked': {\n      color: green[500],\n    },\n  },\n  checked: {},\n};\n```\n\n### Nested components\n\nNested components inside a component have:\n\n- their own flattened properties when these are key to the top level component abstraction, for instance and `id` property for the `Input` component.\n- their own `xxxProps` property when users might need to tweak the internal render method's sub-components, for instance, exposing the `inputProps` and `InputProps` properties on components that use `Input` internally.\n- their own `xxxComponent` property for performing component injection.\n- their own `xxxRef` property when user might need to perform imperative actions, for instance, exposing a `inputRef` property to access the native `input` on the `Input` component. This helps answer the question [\"How can I access the DOM element?\"](/getting-started/faq/#how-can-i-access-the-dom-element)\n\n### Property naming\n\nThe name of a boolean property should be chosen based on the **default value**. For example, the `disabled` attribute on an input element, if supplied, defaults to `true`. This choice allows the shorthand notation:\n\n```diff\n-<Input enabled={false} />\n+<Input disabled />\n```\n\n### Controlled components\n\nMost of the controlled component are controlled via the `value` and the `onChange` properties, however, the `open` / `onClose` / `onOpen` combination is used for display related state.\n\n### boolean vs enum\n\nThere are two options to design the API for the variations of a component: with a *boolean*; or with an *enum*. For example, let's take a button that has different types. Each option has its pros and cons:\n\n- Option 1 *boolean*:\n    \n    ```tsx\n    type Props = {\n    contained: boolean;\n    fab: boolean;\n    };\n    ```\n    \n    This API enabled the shorthand notation: `<Button>`, `<Button contained />`, `<Button fab />`.\n\n- Option 2 *enum*:\n    \n    ```tsx\n    type Props = {\n      variant: 'text' | 'contained' | 'fab';\n    }\n    ```\n    \n    This API is more verbose: `<Button>`, `<Button variant=\"contained\">`, `<Button variant=\"fab\">`.\n    \n    However it prevents an invalid combination from being used, bounds the number of properties exposed, and can easily support new values in the future.\n\nThe Material-UI components use a combination of the two approaches according to the following rules:\n\n- A *boolean* is used when **2** degrees of freedom are required.\n- An *enum* is used when **> 2** degrees of freedom are required, or if there is the possibility that additional degrees of freedom may be required in the future.\n\nGoing back to the previous button example; since it requires 3 degrees of freedom, we use an *enum*.\n\n### Ref\n\nThe `ref` is forwarded to the root element. This means that, without changing the rendered root element via the `component` prop, it is forwarded to the outermost DOM element that which component renders. If you pass a different component via the `component` prop the ref will be attached to that component instead.\n\n## Glossary\n\n- **host component**: a DOM node type in the context of `react-dom`, e.g. a `'div'`. See also [React Implementation Notes](https://reactjs.org/docs/implementation-notes.html#mounting-host-elements).\n- **host element**: a DOM node in the context of `react-dom`, e.g. an instance of `window.HTMLDivElement`.\n- **outermost**: The first component when reading the component tree from top to bottom i.e. breadth-first search.\n- **root component**: the outermost component that renders a host component.\n- **root element**: the outermost element that renders a host component."},"7aBg":function(e,n){e.exports="# API设计方法\n\n<p class=\"description\">开发团队在之前的版本了解了 Material-UI 如何被使用。在v1重写时，重新考虑了组件API的设计方法论。</p>\n\n> API设计的难点在于你可以让一些复杂的东西看起来简单，也可能把简单的东西搞得复杂。\n\n[@sebmarkbage](https://twitter.com/sebmarkbage/status/728433349337841665)\n\n正如Sebastian Markbage [指出](https://2014.jsconf.eu/speakers/sebastian-markbage-minimal-api-surface-area-learning-patterns-instead-of-frameworks.html)，没有抽象优于错误的抽象。 我们提供低级的组件以最大化保留可用性。\n\n## 构成\n\n您可能已经注意到API中有关组合组件的一些不一致之处。 为了提供一些透明度，我们在设计API时一直使用以下规则：\n\n1. 使用` children `属性是使用React进行合成的惯用方法。\n2. 有时我们只需要有限的子组成，例如当我们不需要允许子顺序排列时。 在这种情况下，提供显式属性可以使实现更简单，更高效; 例如，`Tab`采用`icon`和`label`属性。\n3. API一致性很重要。\n\n## 规则\n\n除了上述构成权衡之外，我们还执行以下规则：\n\n### 传播\n\n提供的未记录的属性传播到根元素; 例如，` className `属性应用于根。\n\n现在，假设您要禁用` MenuItem `上的涟漪。 您可以利用传播行为：\n\n```jsx\n<MenuItem disableRipple />\n```\n\n` disableRipple `属性将以这种方式流动：[` MenuItem `](/api/menu-item/)> [` ListItem `](/api/list-item/)> [` ButtonBase `](/api/button-base/)。\n\n### 原生属性\n\n我们避免记录DOM支持的本机属性，如[` className `](/customization/components/#overriding-styles-with-class-names)。\n\n### CSS classes\n\n所有组件都接受[`classes`](/customization/components/#overriding-styles-with-classes)属性来自定义样式。 类设计回答了两个约束： 使类结构尽可能简单，同时足以实现Material Design规范。\n\n- 应用于根元素的类始终称为` root `。\n- 所有默认样式都分组在一个类中。\n- 应用于非根元素的类以元素的名称为前缀，例如， Dialog组件中的` paperWidthXs `。\n- 由布尔属性应用的variants **不是** 前缀，例如 `rounded` 类由 `rounded` 属性应用\n- 由 enum 属性应用的variants ** 是 ** 前缀, 例如 ` colorPrimary ` 类 应用的 ` color = \"primary\" ` 属性。\n- Variant具有 ** 一个特定级别 **。 `color`和`variant`属性被视为variant。 样式特异性越低, 它就越容易覆盖。\n- 我们增加了variant修饰符的特异性。 我们已经 ** 必须这样做 ** 为伪类 (`:hover `, `:focus ` 等)。 它允许更多的控制，但代价是更多的样板。 希望它也更直观。\n\n```js\nconst styles = {\n  root: {\n    color: green[600],\n    '&$checked': {\n      color: green[500],\n    },\n  },\n  checked: {},\n};\n```\n\n### 嵌套的组件\n\n组件内的嵌套组件具有:\n\n- 当它们是顶级组件抽象的关键时，它们自己的扁平属性， 例如，`input`组件的` id `属性。\n- 当用户可能需要调整内部render方法的子组件时，他们自己的` xxxProps `属性，例如，在内部使用`input`的组件上公开` inputProps `和` InputProps `属性。\n- 他们自己的` xxxComponent `属性，用于执行组件注入。\n- 当用户可能需要执行命令性操作时，他们自己的` xxxRef `属性， 例如，公开` inputRef `属性以访问`input`组件上的native `input`。 这有助于回答问题[“我如何访问DOM元素？”](/getting-started/faq/#how-can-i-access-the-dom-element)\n\n### 属性名称\n\n应根据 ** 默认值 ** 选择布尔属性的名称。 例如, 输入元素上的 ` disabled ` 特性 (如果提供) 默认为 ` true `。 此选项允许速记符号:\n\n```diff\n-<Input enabled={false} />\n+<Input disabled />\n```\n\n### 受控组件\n\n大多数受控组件通过 ` value ` 和 ` onChange ` 属性进行控制, 但是, ` onChange `/` onClose `/` onOpen ` 组合用于显示相关状态。\n\n### 布尔值 vs 枚举\n\n为组件的变体设计API有两种选择：使用* boolean*; 或者使用* enum *。 例如, 让我们取一个具有不同类型的按钮。 每个选项都有其优点和缺点:\n\n- 选项 1 * 布尔值(boolean) *:\n    \n    ```tsx\n    type Props = {\n    contained: boolean;\n    fab: boolean;\n    };\n    ```\n    \n    此 API 启用了简写表示法: `<Button>`、` <Button contained /> `、` <Button fab /> `。\n\n- 选项2 *枚举(enum)*\n    \n    ```tsx\n    type Props = {\n      variant: 'text' | 'contained' | 'fab';\n    }\n    ```\n    \n    这个API更详细： `<Button>`,`<Button variant=\"contained\">`,`<Button variant=\"fab\">`。\n    \n    However it prevents an invalid combination from being used, bounds the number of properties exposed, and can easily support new values in the future.\n\nMaterial-UI组件根据以下规则使用两种方法的组合：\n\n- 当需要**2**自由度时，使用*布尔*。\n- 当需要**>2**自由度时，或者如果将来可能需要额外的自由度，则使用*枚举*。\n\n回到上一个按钮示例; 因为它需要3个自由度，所以我们使用* enum *。\n\n### Ref\n\nThe `ref` is forwarded to the root element. This means that, without changing the rendered root element via the `component` prop, it is forwarded to the outermost DOM element that which component renders. If you pass a different component via the `component` prop the ref will be attached to that component instead.\n\n## Glossary\n\n- **host component**: a DOM node type in the context of `react-dom`, e.g. a `'div'`. See also [React Implementation Notes](https://reactjs.org/docs/implementation-notes.html#mounting-host-elements).\n- **host element**: a DOM node in the context of `react-dom`, e.g. an instance of `window.HTMLDivElement`.\n- **outermost**: The first component when reading the component tree from top to bottom i.e. breadth-first search.\n- **root component**: the outermost component that renders a host component.\n- **root element**: the outermost element that renders a host component."},"8vLi":function(e,n){e.exports="# Abordagem de Design da API\n\n<p class=\"description\">Nós aprendemos bastante como o Material-UI é usado e o refatoramento da v1 permitiu-nos repensar completamente o componente de API.</p>\n\n> O design da API é difícil porque você pode fazer com que pareça simples, mas na verdade é extremamente complexo ou simples, mas parece complexo.\n\n[@sebmarkbage](https://twitter.com/sebmarkbage/status/728433349337841665)\n\nComo Sebastian Markbage [apontou](https://2014.jsconf.eu/speakers/sebastian-markbage-minimal-api-surface-area-learning-patterns-instead-of-frameworks.html), nenhuma abstração é superior a abstrações erradas. Estamos fornecendo componentes de baixo nível para maximizar os recursos de composição.\n\n## Composição\n\nVocê deve ter notado alguma inconsistência na API em relação à composição de componentes. Para fornecer alguma transparência, usamos as seguintes regras ao projetar a API:\n\n1. Usando a propriedade `children` é a maneira idiomática de fazer composição com React.\n2. Às vezes, precisamos apenas de uma composição limitada com child, por exemplo, quando não precisamos permitir permutações de ordem com child. Nesse caso, fornecer propriedades explícitas torna a implementação mais simples e com maior desempenho; por exemplo, o componente `Tab` recebe uma propriedade `icon` e `label`.\n3. A consistência da API é importante.\n\n## Regras\n\nAlém do trade-off da composição acima, aplicamos as seguintes regras:\n\n### Propagar\n\nPropriedades não documentadas fornecidas são propagadas no elemento raiz; por exemplo, a propriedade `className` é aplicada à raiz.\n\nAgora, digamos que você queira desabilitar o efeito cascata do `MenuItem`. Você pode aproveitar o comportamento de propagação:\n\n```jsx\n<MenuItem disableRipple />\n```\n\nA propriedade `disableRipple` fluirá desta maneira: [`MenuItem`](/api/menu-item/) > [`ListItem`](/api/list-item/) > [`ButtonBase`](/api/button-base/).\n\n### Propriedades nativas\n\nEvitamos documentar propriedades nativas suportadas pelo DOM como [`className`](/customization/components/#overriding-styles-with-class-names).\n\n### Classes CSS\n\nTodos os componentes aceitam propriedades [`classes`](/customization/components/#overriding-styles-with-classes) para customizar os estilos. O design de classes responde a duas restrições: para tornar a estrutura das classes o mais simples possível, enquanto suficiente, implementa a especificação de Material Design.\n\n- A classe aplicada ao elemento raiz é sempre chamada de `root`.\n- Todos os estilos padrão são agrupados em uma única classe.\n- As classes aplicadas a elementos não-raiz são prefixadas com o nome do elemento, por exemplo, `paperWidthXs` no componente Dialog.\n- As variantes aplicadas por uma propriedade booleana **não são** prefixadas, por exemplo, a classe `rounded` aplicada pela propriedade `rounded`.\n- As variantes aplicadas por uma propriedade enum **são** prefixadas, por exemplo, a classe `colorPrimary` aplicada pela propriedade `color=\"primary\"`.\n- Uma variante tem **um nível de especificidade**. As propriedades `color` e `variant` são consideradas uma variante. Quanto menor a especificidade de estilo, mais simples é sobrescrever.\n- Aumentamos a especificidade de um modificador variante. Nós já **temos que fazer isso** para as pseudo-classes (`:hover`, `:focus`, etc.). Permite muito mais controle ao custo de mais clichê. Esperamos que também seja mais intuitivo.\n\n```js\nconst styles = {\n  root: {\n    color: green[600],\n    '&$checked': {\n      color: green[500],\n    },\n  },\n  checked: {},\n};\n```\n\n### Componentes aninhados\n\nOs componentes aninhados dentro de um componente possuem:\n\n- suas próprias propriedades niveladas quando estas são chaves para a abstração do componente de nível superior, por exemplo a propriedade `id` para o componente `input`.\n- suas próprias propriedades `xxxProps`, quando os usuários podem precisar ajustar os subcomponentes do método de renderização interno, por exemplo, expondo as propriedades `inputProps` e `InputProps` em componentes que usam `Input` internamente.\n- suas próprias propriedades `xxxComponent` para executar a injeção de componentes.\n- suas próprias propriedades `xxxRef`, quando o usuário precisar executar ações imperativas, por exemplo, expondo uma propriedade `inputRef` para acessar nativamente a `entrada` no componente `Input`. Isso ajuda a responder a pergunta [\"Como posso acessar o elemento DOM?\"](/getting-started/faq/#how-can-i-access-the-dom-element)\n\n### Nomeando propriedades\n\nO nome de uma propriedade booleana deve ser escolhido com base no **valor padrão**. Por exemplo, o atributo `disabled` em um elemento de entrada, se fornecido, é padronizado para `true`. Essa escolha permite a notação abreviada:\n\n```diff\n-<Input enabled={false} />\n+<Input disabled />\n```\n\n### Componentes controlados\n\nA maior parte de componentes controlados, é controlado pelas propriedades `value` e `onChange`, no entanto, o `open` / `onClose` / `onOpen` é uma combinação usada para o estado relacionado à exibição.\n\n### boolean vs enum\n\nExistem duas opções para projetar a API para as variações de um componente: com um *boolean*; ou com um *enum*. Por exemplo, vamos pegar um botão que tenha tipos diferentes. Cada opção tem seus prós e contras:\n\n- Opção 1 *boolean*:\n    \n    ```tsx\n    type Props = {\n    contained: boolean;\n    fab: boolean;\n    };\n    ```\n    \n    Esta API ativou a notação abreviada: `<Button>`, `<Button contained />`, `<Button fab />`.\n\n- Opção 2 *enum*:\n    \n    ```tsx\n    type Props = {\n      variant: 'text' | 'contained' | 'fab';\n    }\n    ```\n    \n    Esta API é mais verbosa: `<Button>`, `<Button variant=\"contained\">`, `<Button variant=\"fab\">`.\n    \n    No entanto, isso impede que uma combinação inválida seja usada, limita o número de propriedades expostas, e pode facilmente suportar novos valores no futuro.\n\nOs componentes de Material-UI usam uma combinação das duas abordagens de acordo com as seguintes regras:\n\n- Um *boolean* é usado quando **2** opções de configuração são necessárias.\n- Um *enum* é usado quando **> 2** opções de configuração são necessárias, ou se houver a possibilidade de futuramente, ser necessários a adição de mais opções.\n\nVoltando ao exemplo do botão anterior; ele requer 3 opções de configuração, nesse caso, usamos um *enum*.\n\n### Ref\n\nO `ref` é encaminhado para o elemento raiz. Isso significa que, sem alterar o elemento raiz renderizado através da propriedade `component`, ele é encaminhado para o elemento DOM mais externo para que o componente renderize. Se você passar um componente diferente através da propriedade `component` o ref será anexado para esse componente.\n\n## Glossário\n\n- **componente hospedeiro**: um tipo de nó DOM no contexto de `react-dom`, por exemplo, um `'div'`. Veja também as [Notas de implementação do React](https://reactjs.org/docs/implementation-notes.html#mounting-host-elements).\n- **elemento hospedeiro**: um nó DOM no contexto de `react-dom`, por exemplo, uma instância de `window.HTMLDivElement`.\n- **mais externo**: O primeiro componente ao ler a árvore de componentes de cima para baixo, ou seja, busca em largura (breadth-first search).\n- **componente raiz**: o componente mais externo que renderiza um componente do hospedeiro.\n- **elemento raiz**: o elemento mais externo que renderiza um componente hospedeiro."},QWHD:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/guides/api",function(){var e=t("nsI6");return{page:e.default||e}}])},bdFe:function(e,n){e.exports="# API Design Approach\n\n<p class=\"description\">Nós aprendemos bastante como o Material-UI é usado e o refatoramento da v1 permitiu-nos repensar completamente o componente de API.</p>\n\n> Le design de l'API est difficile car vous pouvez le rendre simple mais il est en fait trompeur complexe, ou le rendre vraiment simple mais semble complexe.\n\n[@sebmarkbage](https://twitter.com/sebmarkbage/status/728433349337841665)\n\nComme Sebastian Markbage [ l'a souligné ](https://2014.jsconf.eu/speakers/sebastian-markbage-minimal-api-surface-area-learning-patterns-instead-of-frameworks.html) , aucune abstraction n'est supérieure aux mauvaises abstractions. Nous fournissons des composants de bas niveau pour optimiser les capacités de composition.\n\n## Composition\n\nVous avez peut-être remarqué des incohérences dans l'API par rapport à la composition des composants. Pour fournir une certaine transparence, nous avons utilisé les règles suivantes lors de la conception de l'API :\n\n1. L'utilisation de la propriété `children` est le moyen idiomatique pour faire la composition avec React.\n2. Par fois, on a juste besoin d'une composition limite par enfants, par example lorsque qu'on n'a pas besoin d'autoriser la permutation d'ordre par enfant. Dans ce cas, fournir des propriétés explicites rend l'implémentation plus simple et plus performante; par example, `Tab` prend `icon` et une propriété `label`.\n3. La cohérence des API est importante.\n\n## Règles\n\nOutre le compromis de composition ci-dessus, nous appliquons les règles suivantes:\n\n### La propagation\n\nLes propriétés non documentées fournies sont propagées à l'élément racine. par exemple, la propriété ` className ` est appliquée à la racine.\n\nMaintenant, supposons que vous vouliez désactiver les ondulations sur le `MenuItem`. Vous pouvez tirer parti du comportement de propagation :\n\n```jsx\n<MenuItem disableRipple />\n```\n\nLa propriété `disableRipple` va suivre de cette façon : [`MenuItem`](/api/menu-item/) > [`ListItem`](/api/list-item/) > [`ButtonBase`](/api/button-base/).\n\n### Les Propriétés natives\n\nNous évitons de documenter les propriétés natives supportées par le DOM, comme [` className `](/customization/components/#overriding-styles-with-class-names) .\n\n### Les Classes CSS\n\nTous les composants acceptent une propriété [` classes `](/customization/components/#overriding-styles-with-classes) pour personnaliser les styles. The classes design answers two constraints: to make the classes structure as simple as possible, while sufficient to implement the Material Design specification.\n\n- The class applied to the root element is always called `root`.\n- All the default styles are grouped in a single class.\n- The classes applied to non-root elements are prefixed with the name of the element, e.g. `paperWidthXs` in the Dialog component.\n- The variants applied by a boolean property **aren't** prefixed, e.g. the `rounded` class applied by the `rounded` property.\n- The variants applied by an enum property **are** prefixed, e.g. the `colorPrimary` class applied by the `color=\"primary\"` property.\n- A variant has **one level of specificity**. The `color` and `variant` properties are considered a variant. The lower the style specificity is, the simpler it is to override.\n- We increase the specificity for a variant modifier. We already **have to do it** for the pseudo-classes (`:hover`, `:focus`, etc.). It allows much more control at the cost of more boilerplate. Hopefully, it's also more intuitive.\n\n```js\nconst styles = {\n  root: {\n    color: green[600],\n    '&$checked': {\n      color: green[500],\n    },\n  },\n  checked: {},\n};\n```\n\n### Nested components\n\nNested components inside a component have:\n\n- their own flattened properties when these are key to the top level component abstraction, for instance and `id` property for the `Input` component.\n- their own `xxxProps` property when users might need to tweak the internal render method's sub-components, for instance, exposing the `inputProps` and `InputProps` properties on components that use `Input` internally.\n- their own `xxxComponent` property for performing component injection.\n- their own `xxxRef` property when user might need to perform imperative actions, for instance, exposing a `inputRef` property to access the native `input` on the `Input` component. This helps answer the question [\"How can I access the DOM element?\"](/getting-started/faq/#how-can-i-access-the-dom-element)\n\n### Property naming\n\nThe name of a boolean property should be chosen based on the **default value**. For example, the `disabled` attribute on an input element, if supplied, defaults to `true`. This choice allows the shorthand notation:\n\n```diff\n-<Input enabled={false} />\n+<Input disabled />\n```\n\n### Controlled components\n\nMost of the controlled component are controlled via the `value` and the `onChange` properties, however, the `open` / `onClose` / `onOpen` combination is used for display related state.\n\n### boolean vs enum\n\nThere are two options to design the API for the variations of a component: with a *boolean*; or with an *enum*. For example, let's take a button that has different types. Each option has its pros and cons:\n\n- Option 1 *boolean*:\n    \n    ```tsx\n    type Props = {\n    contained: boolean;\n    fab: boolean;\n    };\n    ```\n    \n    This API enabled the shorthand notation: `<Button>`, `<Button contained />`, `<Button fab />`.\n\n- Option 2 *enum*:\n    \n    ```tsx\n    type Props = {\n      variant: 'text' | 'contained' | 'fab';\n    }\n    ```\n    \n    This API is more verbose: `<Button>`, `<Button variant=\"contained\">`, `<Button variant=\"fab\">`.\n    \n    However it prevents an invalid combination from being used, bounds the number of properties exposed, and can easily support new values in the future.\n\nThe Material-UI components use a combination of the two approaches according to the following rules:\n\n- A *boolean* is used when **2** degrees of freedom are required.\n- An *enum* is used when **> 2** degrees of freedom are required, or if there is the possibility that additional degrees of freedom may be required in the future.\n\nGoing back to the previous button example; since it requires 3 degrees of freedom, we use an *enum*.\n\n### Ref\n\nThe `ref` is forwarded to the root element. This means that, without changing the rendered root element via the `component` prop, it is forwarded to the outermost DOM element that which component renders. If you pass a different component via the `component` prop the ref will be attached to that component instead.\n\n## Glossary\n\n- **host component**: a DOM node type in the context of `react-dom`, e.g. a `'div'`. See also [React Implementation Notes](https://reactjs.org/docs/implementation-notes.html#mounting-host-elements).\n- **host element**: a DOM node in the context of `react-dom`, e.g. an instance of `window.HTMLDivElement`.\n- **outermost**: The first component when reading the component tree from top to bottom i.e. breadth-first search.\n- **root component**: the outermost component that renders a host component.\n- **root element**: the outermost element that renders a host component."},buWv:function(e,n){e.exports='# crwdns95186:0crwdne95186:0\n\n<p class="description">crwdns95188:0crwdne95188:0</p>\n\n> crwdns95190:0crwdne95190:0\n\n[crwdns95194:0crwdne95194:0](crwdns95192:0crwdne95192:0)\n\ncrwdns95196:0crwdne95196:0 crwdns95198:0crwdne95198:0\n\n## crwdns95200:0crwdne95200:0\n\ncrwdns95202:0crwdne95202:0 crwdns95204:0crwdne95204:0\n\n1. crwdns95206:0crwdne95206:0\n2. crwdns95208:0crwdne95208:0 crwdns95210:0crwdne95210:0\n3. crwdns95212:0crwdne95212:0\n\n## crwdns95214:0crwdne95214:0\n\ncrwdns95216:0crwdne95216:0\n\n### crwdns95218:0crwdne95218:0\n\ncrwdns95220:0crwdne95220:0\n\ncrwdns95222:0crwdne95222:0 crwdns95224:0crwdne95224:0\n\n```jsx\ncrwdns95226:0crwdne95226:0\n```\n\ncrwdns95228:0crwdne95228:0\n\n### crwdns95230:0crwdne95230:0\n\ncrwdns95232:0crwdne95232:0\n\n### crwdns95234:0crwdne95234:0\n\ncrwdns95236:0crwdne95236:0 crwdns95238:0crwdne95238:0\n\n- crwdns95240:0crwdne95240:0\n- crwdns95242:0crwdne95242:0\n- crwdns95244:0crwdne95244:0\n- crwdns95246:0crwdne95246:0\n- crwdns95248:0crwdne95248:0\n- crwdns95250:0crwdne95250:0 crwdns95252:0crwdne95252:0 crwdns95254:0crwdne95254:0\n- crwdns95256:0crwdne95256:0 crwdns95258:0crwdne95258:0 crwdns95260:0crwdne95260:0 crwdns95262:0crwdne95262:0\n\n```js\ncrwdns95264:0[600]crwdnd95264:0$checkedcrwdnd95264:0[500]crwdne95264:0\n```\n\n### crwdns95266:0crwdne95266:0\n\ncrwdns95268:0crwdne95268:0\n\n- crwdns95270:0crwdne95270:0\n- crwdns95272:0crwdne95272:0\n- crwdns95274:0crwdne95274:0\n- crwdns95276:0crwdne95276:0 crwdns95278:0crwdne95278:0\n\n### crwdns95280:0crwdne95280:0\n\ncrwdns95282:0crwdne95282:0 crwdns95284:0crwdne95284:0 crwdns95286:0crwdne95286:0\n\n```diff\ncrwdns95288:0{false}crwdne95288:0\n```\n\n### crwdns95290:0crwdne95290:0\n\ncrwdns95292:0crwdne95292:0\n\n### crwdns95294:0crwdne95294:0\n\ncrwdns95296:0crwdne95296:0 crwdns95298:0crwdne95298:0 crwdns95300:0crwdne95300:0\n\n- crwdns95302:0crwdne95302:0\n    \n    ```tsx\n    crwdns95304:0crwdne95304:0\n    ```\n    \n    crwdns95306:0crwdne95306:0\n\n- crwdns95308:0crwdne95308:0\n    \n    ```tsx\n    crwdns95310:0crwdne95310:0\n    ```\n    \n    crwdns95312:0crwdne95312:0\n    \n    crwdns95314:0crwdne95314:0\n\ncrwdns95316:0crwdne95316:0\n\n- crwdns95318:0crwdne95318:0\n- crwdns95320:0crwdne95320:0\n\ncrwdns95322:0crwdne95322:0\n\n### crwdns95324:0crwdne95324:0\n\ncrwdns95326:0crwdne95326:0 crwdns95328:0crwdne95328:0 crwdns95330:0crwdne95330:0\n\n## crwdns95332:0crwdne95332:0\n\n- crwdns95334:0crwdne95334:0 crwdns95336:0crwdne95336:0\n- crwdns95338:0crwdne95338:0\n- crwdns95340:0crwdne95340:0\n- crwdns95342:0crwdne95342:0\n- crwdns95344:0crwdne95344:0'},i5rY:function(e,n){e.exports="# API Design Approach\n\n<p class=\"description\">We have learned a great deal regarding how Material-UI is used, and the v1 rewrite allowed us to completely rethink the component API.</p>\n\n> API design is hard because you can make it seem simple but it's actually deceptively complex, or make it actually simple but seem complex.\n\n[@sebmarkbage](https://twitter.com/sebmarkbage/status/728433349337841665)\n\nAs Sebastian Markbage [pointed out](https://2014.jsconf.eu/speakers/sebastian-markbage-minimal-api-surface-area-learning-patterns-instead-of-frameworks.html), no abstraction is superior to wrong abstractions.\nWe are providing low-level components to maximize composition capabilities.\n\n## Composition\n\nYou may have noticed some inconsistency in the API regarding composing components.\nTo provide some transparency, we have been using the following rules when designing the API:\n\n1. Using the `children` property is the idiomatic way to do composition with React.\n2. Sometimes we only need limited child composition, for instance when we don't need to allow child order permutations.\nIn this case, providing explicit properties makes the implementation simpler and more performant; for example, the `Tab` takes an `icon` and a `label` property.\n3. API consistency matters.\n\n## Rules\n\nAside from the above composition trade-off, we enforce the following rules:\n\n### Spread\n\nUndocumented properties supplied are spread to the root element;\nfor instance, the `className` property is applied to the root.\n\nNow, let's say you want to disable the ripples on the `MenuItem`.\nYou can take advantage of the spread behavior:\n```jsx\n<MenuItem disableRipple />\n```\nThe `disableRipple` property will flow this way: [`MenuItem`](/api/menu-item/) > [`ListItem`](/api/list-item/) > [`ButtonBase`](/api/button-base/).\n\n### Native properties\n\nWe avoid documenting native properties supported by the DOM like [`className`](/customization/components/#overriding-styles-with-class-names).\n\n### CSS Classes\n\nAll the components accept a [`classes`](/customization/components/#overriding-styles-with-classes) property to customize the styles.\nThe classes design answers two constraints:\nto make the classes structure as simple as possible, while sufficient to implement the Material Design specification.\n- The class applied to the root element is always called `root`.\n- All the default styles are grouped in a single class.\n- The classes applied to non-root elements are prefixed with the name of the element, e.g. `paperWidthXs` in the Dialog component.\n- The variants applied by a boolean property **aren't** prefixed, e.g. the `rounded` class\napplied by the `rounded` property.\n- The variants applied by an enum property **are** prefixed, e.g. the `colorPrimary` class\napplied by the `color=\"primary\"` property.\n- A variant has **one level of specificity**.\nThe `color` and `variant` properties are considered a variant.\nThe lower the style specificity is, the simpler it is to override.\n- We increase the specificity for a variant modifier.\nWe already **have to do it** for the pseudo-classes (`:hover`, `:focus`, etc.).\nIt allows much more control at the cost of more boilerplate.\nHopefully, it's also more intuitive.\n\n```js\nconst styles = {\n  root: {\n    color: green[600],\n    '&$checked': {\n      color: green[500],\n    },\n  },\n  checked: {},\n};\n```\n\n### Nested components\n\nNested components inside a component have:\n- their own flattened properties when these are key to the top level component abstraction,\n  for instance and `id` property for the `Input` component.\n- their own `xxxProps` property when users might need to tweak the internal render method's sub-components,\n  for instance, exposing the `inputProps` and `InputProps` properties on components that use `Input` internally.\n- their own `xxxComponent` property for performing component injection.\n- their own `xxxRef` property when user might need to perform imperative actions,\n  for instance, exposing a `inputRef` property to access the native `input` on the `Input` component.\n  This helps answer the  question [\"How can I access the DOM element?\"](/getting-started/faq/#how-can-i-access-the-dom-element)\n\n### Property naming\n\nThe name of a boolean property should be chosen based on the **default value**.\nFor example, the `disabled` attribute on an input element, if supplied, defaults to `true`.\nThis choice allows the shorthand notation:\n\n```diff\n-<Input enabled={false} />\n+<Input disabled />\n```\n\n### Controlled components\n\nMost of the controlled component are controlled via the `value` and the `onChange` properties,\nhowever, the `open` / `onClose` / `onOpen` combination is used for display related state.\n\n### boolean vs enum\n\nThere are two options to design the API for the variations of a component: with a *boolean*; or with an *enum*.\nFor example, let's take a button that has different types. Each option has its pros and cons:\n\n- Option 1 *boolean*:\n\n  ```tsx\n  type Props = {\n    contained: boolean;\n    fab: boolean;\n  };\n  ```\n\n   This API enabled the shorthand notation:\n   `<Button>`, `<Button contained />`, `<Button fab />`.\n\n- Option 2 *enum*:\n\n  ```tsx\n  type Props = {\n    variant: 'text' | 'contained' | 'fab';\n  }\n  ```\n\n  This API is more verbose:\n  `<Button>`, `<Button variant=\"contained\">`, `<Button variant=\"fab\">`.\n\n   However it prevents an invalid combination from being used,\n   bounds the number of properties exposed,\n   and can easily support new values in the future.\n\nThe Material-UI components use a combination of the two approaches according to the following rules:\n- A *boolean* is used when **2** degrees of freedom are required.\n- An *enum* is used when **> 2** degrees of freedom are required, or if there is the possibility that additional degrees of freedom may be required in the future.\n\nGoing back to the previous button example; since it requires 3 degrees of freedom, we use an *enum*.\n\n### Ref\n\nThe `ref` is forwarded to the root element. This means that, without changing the rendered root element\nvia the `component` prop, it is forwarded to the outermost DOM element that which component\nrenders. If you pass a different component via the `component` prop the ref will be attached\nto that component instead.\n\n## Glossary\n\n- **host component**: a DOM node type in the context of `react-dom`, e.g. a `'div'`. See also [React Implementation Notes](https://reactjs.org/docs/implementation-notes.html#mounting-host-elements).\n- **host element**: a DOM node in the context of `react-dom`, e.g. an instance of `window.HTMLDivElement`.\n- **outermost**: The first component when reading the component tree from top to bottom i.e. breadth-first search.\n- **root component**: the outermost component that renders a host component.\n- **root element**: the outermost element that renders a host component.\n"},lQw3:function(e,n,t){var o={"./api-aa.md":"buWv","./api-de.md":"ryit","./api-es.md":"xEAs","./api-fr.md":"bdFe","./api-ja.md":"2iYb","./api-pt.md":"8vLi","./api-ru.md":"0wvg","./api-zh.md":"7aBg","./api.md":"i5rY"};function a(e){var n=s(e);return t(n)}function s(e){var n=o[e];if(!(n+1)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return n}a.keys=function(){return Object.keys(o)},a.resolve=s,e.exports=a,a.id="lQw3"},lnTB:function(e,n){function t(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}t.keys=function(){return[]},t.resolve=t,e.exports=t,t.id="lnTB"},nsI6:function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return d});var o=t("mXGw"),a=t.n(o),s=t("e+1t"),r=t("lQw3"),i=t("lnTB"),p=a.a.createElement(s.a,{req:r,reqSource:i,reqPrefix:"pages/guides/api"});function d(){return p}},ryit:function(e,n){e.exports="# API-Design-Ansatz\n\n<p class=\"description\">Wir haben viel über die Verwendung von Material-UI gelernt, und durch das Umschreiben von Version 1 konnten wir die Komponenten-API vollständig überdenken.</p>\n\n> Das API-Design ist schwierig, weil man es einfach erscheinen lassen kann, aber es ist tatsächlich täuschend komplex ist, oder man macht die API einfach, aber die Umsetzung komplex.\n\n[@sebmarkbage](https://twitter.com/sebmarkbage/status/728433349337841665)\n\nWie Sebastian Markbage [sagt](https://2014.jsconf.eu/speakers/sebastian-markbage-minimal-api-surface-area-learning-patterns-instead-of-frameworks.html): Keine Abstraktion ist falschen Abstraktionen überlegen. Wir bieten Komponenten auf niedriger Ebene an, um die Kompositionsfähigkeiten zu maximieren.\n\n## Komposition\n\nMöglicherweise haben Sie bei der Erstellung von Komponenten Inkonsistenzen in der API festgestellt. Um für mehr Transparenz zu sorgen, haben wir beim Entwurf der API die folgenden Regeln verwendet:\n\n1. Verwenden der `children` Eigenschaft ist der idiomatische Weg, um mit React zu komponieren.\n2. Manchmal benötigen wir nur eine eingeschränkte Zusammensetzung von Kidnern, zum Beispiel, wenn wir keine Permutationen für untergeordnete Elemente zulassen müssen. In diesem Fall macht die Angabe expliziter Eigenschaften die Implementierung einfacher und performanter. Zum Beispiel nimmt ein `Tab` ein `icon` und `label` als Eigenschaft an.\n3. Die API-Konsistenz ist wichtig.\n\n## Regeln\n\nAbgesehen von den oben genannten Kompensationsregeln setzen wir die folgenden Regeln durch:\n\n### Verteilt\n\nNicht dokumentierte Eigenschaften werden auf das Stammelement verteilt. zum Beispiel wird die `className`Eigenschaft auf die Wurzel angewendet.\n\nAngenommen, Sie möchten die Wellen im `Menüelement` deaktivieren. Sie können das Ausbreitungsverhalten nutzen:\n\n```jsx\n<MenuItem disableRipple />\n```\n\nDie Eigenschaft `disableRipple` wird folgendermaßen weitergegeben: [`MenuItem`](/api/menu-item/) > [`ListItem`](/api/list-item/) > [`ButtonBase`](/api/button-base/).\n\n### Native Eigenschaften\n\nWir vermeiden, die vom DOM unterstützten nativen Eigenschaften wie [`className`](/customization/components/#overriding-styles-with-class-names) zu dokumentieren.\n\n### CSS-Klassen\n\nAlle Komponenten akzeptieren die [`classes`](/customization/components/#overriding-styles-with-classes) Eigenschaft zum Anpassen der Stile. Das Design der classes beantwortet zwei Bedingungen: Die Klassenstruktur so einfach wie möglich zu gestalten, aber trotzdem ausreichend, um die Material Design-Spezifikation zu implementieren.\n\n- Die auf das Wurzelelement angewendete Klasse wird immer als `root` bezeichnet.\n- Alle Standardstile sind in einer einzigen Klasse zusammengefasst.\n- Die auf Nicht-Root-Elemente angewendeten Klassen wird der Name des Elements vorangestellt, z. B. `paperWidthXs` in der Dialogkomponente.\n- Die von einer booleschen Eigenschaft angewendeten Varianten sind **nicht** vorangestellt, zB die `rounded` Klasse wird durch die `rounded` Eigenschaft angewendet.\n- Die von einer Enumeneigenschaft angewendeten Varianten **sind** vorangestellt, z. B. die `colorPrimary` Klasse wird von der Farbe `color= \"primary\" ` Eigenschaft angewendet.\n- Eine Variante hat **eine Spezifitätsebene**. Die `color` und `variant` Eigenscahft werden als Variant betrachtet. Je geringer die Stilspezifität ist, desto einfacher ist es, sie zu überschreiben.\n- Wir erhöhen die Spezifität für einen Variantenmodifikator. Wir ** müssen es schon ** für die Pseudoklassen (`:hover`, `:focus`, usw.) anwenden. Es ermöglicht viel mehr Kontrolle auf Kosten von mehr Boilerplate. Hoffentlich ist es auch intuitiver.\n\n```js\nconst styles = {\n  root: {\n    color: green[600],\n    '&$checked': {\n      color: green[500],\n    },\n  },\n  checked: {},\n};\n```\n\n### Verschachtelte Komponenten\n\nVerschachtelte Komponenten in einer Komponente haben:\n\n- ihre eigenen abgeflachten Eigenschaften, wenn diese der Schlüssel für die Abstraktion der Komponenten der obersten Ebene sind, eine Instanz und eine `id` Eigenschaft für die `Input` Komponente.\n- ihre eigenen `xxxProps ` Eigenschaft, falls Benutzer möglicherweise die Unterkomponenten der internen Render-Methode anpassen müssen, z. B. die `inputProps` und `InputProps` Eigenschaften für Komponenten, die `Input` intern verwenden.\n- ihre eigene `xxxComponent` Eigenschaft zum Durchführen der Komponenteninjektion.\n- ihre eigene `xxxRef` Eigenschaft, falls der Benutzer möglicherweise zwingende Aktionen ausführen muss, z. B. eine `inputRef` Eigenschaft verfügbar machen, um auf ein natives `input` Element der `Input` Komponente zuzugreifen. Dies hilft bei der Beantwortung der Frage [\"Wie kann ich auf das DOM-Element zugreifen?\"](/getting-started/faq/#how-can-i-access-the-dom-element)\n\n### Benennung der Eigenschaften\n\nDer Name einer booleschen Eigenschaft sollte basierend auf dem **Standardwert** ausgewählt werden. Zum Beispiel ist das `disabled` Attribut für ein Eingabeelement, sofern angegeben, standardmäßig auf `true` gesetzt. Diese Wahl erlaubt die Kurzschreibweise:\n\n```diff\n-<Input enabled={false} />\n+<Input disabled />\n```\n\n### Kontrollierte Komponenten\n\nDer überwiegende Teil der kontrollierten Komponente wird über die `value` und `onChange` Eigenschaften gesteuert, jedoch werden die `open` / `onClose` / `onOpen` Kombination wird für den Anzeigezustand verwendet.\n\n### boolean vs enum\n\nEs gibt zwei Möglichkeiten, die API für die Variationen einer Komponente zu entwerfen: mit einem * Booleschen Wert*; oder mit einer *Aufzählung (enum)*. Nehmen wir zum Beispiel einen Button, die verschiedene Typen hat. Jede Option hat ihre Vor- und Nachteile:\n\n- Option 1 *boolean*:\n    \n    ```tsx\n    type Props = {\n    contained: boolean;\n    fab: boolean;\n    };\n    ```\n    \n    Diese API hat die Kurzschreibweise aktiviert: `<Button>`, `<Button contained />`, `<Button fab />`.\n\n- Option 2 *enum*:\n    \n    ```tsx\n    type Props = {\n      variant: 'text' | 'contained' | 'fab';\n    }\n    ```\n    \n    Diese API ist ausführlicher: `<Button>`, `<Button variant=\"contained\">`, `<Button variant=\"fab\">`.\n    \n    However it prevents an invalid combination from being used, bounds the number of properties exposed, and can easily support new values in the future.\n\nDie Komponenten der Material-UI verwenden eine Kombination der beiden Ansätze gemäß den folgenden Regeln:\n\n- Ein *boolean* wird verwendet, wenn **2** Freiheitsgrade erforderlich sind.\n- Eine *Aufzählung* wird verwendet, wenn **> 2** Freiheitsgrade erforderlich sind, oder wenn die Möglichkeit besteht, dass in Zukunft zusätzliche Freiheitsgrade erforderlich sind.\n\nZurück zum vorherigen Beispiel des Buttons; Da 3 Freiheitsgrade erforderlich sind, verwenden wir eine *Aufzählung*.\n\n### Ref\n\nDas `ref` Element wird an das Wurzelelement weitergeleitet. Das bedeutet, ohne das gerenderte Wurzelelement über die `component` Eigenschaft zu ändern, wird an das äußerste DOM-Element weitergeleitet, welche Komponente rendert. Wenn Sie eine andere Komponente über die `compnent` Eigenschaft wird der Ref stattdessen an diese Komponente angehängt.\n\n## Glossar\n\n- **host component**: ein DOM-Knotentype im Kontext von `react-dom`, z.B. ein `'div'`. Siehe auch [React Implementation Notes](https://reactjs.org/docs/implementation-notes.html#mounting-host-elements).\n- **host element**: in DOM-Knoten im Kontext von `react-dom` z.B. eine Instanz von `window.HTMLDivElement`.\n- **outermost**: Die erste Komponente, wenn der Komponentenbaum von oben nach unten gelesen wird, dh die Breitensuche.\n- ** Wurzelkomponente**: Die äußerste Komponente, die eine Hostkomponente darstellt.\n- ** Wurzelelement**: Das äußerste Element, das eine Hostkomponente darstellt."},xEAs:function(e,n){e.exports="# API Design Approach\n\n<p class=\"description\">Nós aprendemos bastante como o Material-UI é usado e o refatoramento da v1 permitiu-nos repensar completamente o componente de API.</p>\n\n> API design is hard because you can make it seem simple but it's actually deceptively complex, or make it actually simple but seem complex.\n\n[@sebmarkbage](https://twitter.com/sebmarkbage/status/728433349337841665)\n\nAs Sebastian Markbage [pointed out](https://2014.jsconf.eu/speakers/sebastian-markbage-minimal-api-surface-area-learning-patterns-instead-of-frameworks.html), no abstraction is superior to wrong abstractions. We are providing low-level components to maximize composition capabilities.\n\n## Composición\n\nYou may have noticed some inconsistency in the API regarding composing components. To provide some transparency, we have been using the following rules when designing the API:\n\n1. Using the `children` property is the idiomatic way to do composition with React.\n2. Sometimes we only need limited child composition, for instance when we don't need to allow child order permutations. In this case, providing explicit properties makes the implementation simpler and more performant; for example, the `Tab` takes an `icon` and a `label` property.\n3. API consistency matters.\n\n## Rules\n\nAside from the above composition trade-off, we enforce the following rules:\n\n### Spread\n\nUndocumented properties supplied are spread to the root element; for instance, the `className` property is applied to the root.\n\nNow, let's say you want to disable the ripples on the `MenuItem`. You can take advantage of the spread behavior:\n\n```jsx\n<MenuItem disableRipple />\n```\n\nThe `disableRipple` property will flow this way: [`MenuItem`](/api/menu-item/) > [`ListItem`](/api/list-item/) > [`ButtonBase`](/api/button-base/).\n\n### Native properties\n\nWe avoid documenting native properties supported by the DOM like [`className`](/customization/components/#overriding-styles-with-class-names).\n\n### CSS Classes\n\nAll the components accept a [`classes`](/customization/components/#overriding-styles-with-classes) property to customize the styles. The classes design answers two constraints: to make the classes structure as simple as possible, while sufficient to implement the Material Design specification.\n\n- The class applied to the root element is always called `root`.\n- All the default styles are grouped in a single class.\n- The classes applied to non-root elements are prefixed with the name of the element, e.g. `paperWidthXs` in the Dialog component.\n- The variants applied by a boolean property **aren't** prefixed, e.g. the `rounded` class applied by the `rounded` property.\n- The variants applied by an enum property **are** prefixed, e.g. the `colorPrimary` class applied by the `color=\"primary\"` property.\n- A variant has **one level of specificity**. The `color` and `variant` properties are considered a variant. The lower the style specificity is, the simpler it is to override.\n- We increase the specificity for a variant modifier. We already **have to do it** for the pseudo-classes (`:hover`, `:focus`, etc.). It allows much more control at the cost of more boilerplate. Hopefully, it's also more intuitive.\n\n```js\nconst styles = {\n  root: {\n    color: green[600],\n    '&$checked': {\n      color: green[500],\n    },\n  },\n  checked: {},\n};\n```\n\n### Nested components\n\nNested components inside a component have:\n\n- their own flattened properties when these are key to the top level component abstraction, for instance and `id` property for the `Input` component.\n- their own `xxxProps` property when users might need to tweak the internal render method's sub-components, for instance, exposing the `inputProps` and `InputProps` properties on components that use `Input` internally.\n- their own `xxxComponent` property for performing component injection.\n- their own `xxxRef` property when user might need to perform imperative actions, for instance, exposing a `inputRef` property to access the native `input` on the `Input` component. This helps answer the question [\"How can I access the DOM element?\"](/getting-started/faq/#how-can-i-access-the-dom-element)\n\n### Property naming\n\nThe name of a boolean property should be chosen based on the **default value**. For example, the `disabled` attribute on an input element, if supplied, defaults to `true`. This choice allows the shorthand notation:\n\n```diff\n-<Input enabled={false} />\n+<Input disabled />\n```\n\n### Controlled components\n\nMost of the controlled component are controlled via the `value` and the `onChange` properties, however, the `open` / `onClose` / `onOpen` combination is used for display related state.\n\n### boolean vs enum\n\nThere are two options to design the API for the variations of a component: with a *boolean*; or with an *enum*. For example, let's take a button that has different types. Each option has its pros and cons:\n\n- Option 1 *boolean*:\n    \n    ```tsx\n    type Props = {\n    contained: boolean;\n    fab: boolean;\n    };\n    ```\n    \n    This API enabled the shorthand notation: `<Button>`, `<Button contained />`, `<Button fab />`.\n\n- Option 2 *enum*:\n    \n    ```tsx\n    type Props = {\n      variant: 'text' | 'contained' | 'fab';\n    }\n    ```\n    \n    This API is more verbose: `<Button>`, `<Button variant=\"contained\">`, `<Button variant=\"fab\">`.\n    \n    However it prevents an invalid combination from being used, bounds the number of properties exposed, and can easily support new values in the future.\n\nThe Material-UI components use a combination of the two approaches according to the following rules:\n\n- A *boolean* is used when **2** degrees of freedom are required.\n- An *enum* is used when **> 2** degrees of freedom are required, or if there is the possibility that additional degrees of freedom may be required in the future.\n\nGoing back to the previous button example; since it requires 3 degrees of freedom, we use an *enum*.\n\n### Ref\n\nThe `ref` is forwarded to the root element. This means that, without changing the rendered root element via the `component` prop, it is forwarded to the outermost DOM element that which component renders. If you pass a different component via the `component` prop the ref will be attached to that component instead.\n\n## Glossary\n\n- **host component**: a DOM node type in the context of `react-dom`, e.g. a `'div'`. See also [React Implementation Notes](https://reactjs.org/docs/implementation-notes.html#mounting-host-elements).\n- **host element**: a DOM node in the context of `react-dom`, e.g. an instance of `window.HTMLDivElement`.\n- **outermost**: The first component when reading the component tree from top to bottom i.e. breadth-first search.\n- **root component**: the outermost component that renders a host component.\n- **root element**: the outermost element that renders a host component."}},[["QWHD","5d41","9da1"]]]);