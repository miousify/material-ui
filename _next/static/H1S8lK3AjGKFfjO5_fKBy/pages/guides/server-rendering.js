(window.webpackJsonp=window.webpackJsonp||[]).push([["3479"],{"634K":function(e,n){e.exports="# 服务端渲染\n\n<p class=\"description\">服务器端呈现的最常见用例是在用户（或搜索引擎爬虫）首次请求您的应用时处理初次渲染。</p>\n\n当服务器收到请求时，它会将所需的组件呈现为 HTML 字符串，然后将其作为响应发送给客户端。 从那时起，客户将接管渲染的职责。\n\n## 在服务器端的 Material-UI\n\nMaterial-UI 最初设计受到了在服务器端渲染的约束，但是您可以完全负责它的正确整合。 为页面提供所需的 CSS 是至关重要的，否则页面只会渲染 HTML 而等待客户端注入 CSS, 从而导致浏览器样式闪烁（FOUC）。 若想将样式注入客户端，我们需要：\n\n1. 在每个请求上创建一个全新的 [`ServerStyleSheets`](/styles/api/#serverstylesheets) 实例。\n2. 用服务端收集器渲染 React 树组件。\n3. 拉出 CSS。\n4. 将CSS传递给客户端。\n\n在删除服务器端注入的 CSS 之前，客户端将第二次注入 CSS。\n\n## 配置\n\n在下面的配置中，我们将了解如何设置服务器端的渲染。\n\n### 主题\n\n我们创建了一个能在客户端和服务器端共享的主题。\n\n`theme.js`\n\n```js\nimport { createMuiTheme } from '@material-ui/core/styles';\nimport red from '@material-ui/core/colors/red';\n\n// 创建一个主题的实例。\nconst theme = createMuiTheme({\n  palette: {\n    primary: {\n      main: '#556cd6',\n    },\n    secondary: {\n      main: '#19857b',\n    },\n    error: {\n      main: red.A400,\n    },\n    background: {\n      default: '#fff',\n    },\n  },\n});\n```\n\n### 服务器端\n\n下面的大纲可以大致展现一下我们的服务器端。 我们将使用 [app.use](https://expressjs.com/en/api.html) 来设置一个 [Express 的中间件](https://expressjs.com/en/guide/using-middleware.html)，从而处理来自我们服务器端的所有请求。 如果您对 Express 或者 middleware 不太熟悉，您只需要知道每次服务器收到了一个请求，都会调用我们的 handleRender 函数。\n\n`server.js`\n\n```js\nimport express from 'express';\n\n// 我们将在章节中填写这些内容来遵守。\nfunction renderFullPage(html, css) {\n  /* ... */\n}\n\nfunction handleRender(req, res) {\n  /* ... */\n}\n\nconst app = express();\n\n// 每次服务器端收到请求时都会触发此操作。\napp.use(handleRender);\n\nconst port = 3000;\napp.listen(port);\n```\n\n### 处理请求\n\n对于每次请求，我们首先需要做的是创建一个 `ServerStyleSheets`。\n\n当渲染的时候，我们将我们的根部组件，`App`，包装在一个 [`StylesProvider`](/styles/api/#stylesprovider) 和 [`ThemeProvider`](/styles/api/#themeprovider) 中，这样组件树中的所有组件都可以使用撰写的样式设置和 `theme`。\n\n服务器渲染的关键步骤是在我们发送到客户端**之前**渲染我们组件的初始 HTML。 我们用 [ReactDOMServer.renderToString()](https://reactjs.org/docs/react-dom-server.html) 来实现此操作。\n\n接着，我们可以使用 `sheets.toString()` 来从我们的`表单`中得到 CSS。 我们将会了解到这是如何在我们的 `renderFullPage` 函数中传递下去的。\n\n```jsx\nimport express from 'express';\nimport React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport { ServerStyleSheets, ThemeProvider } from '@material-ui/styles';\nimport App from './App';\nimport theme from './theme';\n\nfunction handleRender(req, res) {\n  const sheets = new ServerStyleSheets();\n\n  // 将组件渲染成一个字符串。\n  const html = ReactDOMServer.renderToString(\n    sheets.collect(\n      <ThemeProvider theme={theme}>\n        <App />\n      </ThemeProvider>,\n    ),\n  );\n\n  // 从我们的样式表中获取 CSS。\n  const css = sheets.toString();\n\n  // 将渲染的页面送回到客户端。\n  res.send(renderFullPage(html, css));\n}\n\nconst app = express();\n\napp.use('/build', express.static('build'));\n\n// 每次服务器端收到请求时都会触发此操作。\napp.use(handleRender);\n\nconst port = 3000;\napp.listen(port);\n```\n\n### 注入组件的初始 HTML 和 CSS\n\n服务器端最后一个步骤则是在我们的组件初始 HTML 和 CSS 中注入一个模板，从而在客户端渲染。\n\n```js\nfunction renderFullPage(html, css) {\n  return `\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>My page</title>\n        <style id=\"jss-server-side\">${css}</style>\n      </head>\n      <body>\n        <div id=\"root\">${html}</div>\n      </body>\n    </html>\n  `;\n}\n```\n\n### 客户端\n\n客户端则是简单明了的。 我们只需要移除服务器端生成的 CSS。 让我们来看一看我们客户端的文件：\n\n`client.js`\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { ThemeProvider } from '@material-ui/styles';\nimport App from './App';\nimport theme from './theme';\n\nfunction Main() {\n  React.useEffect(() => {\n    const jssStyles = document.querySelector('#jss-server-side');\n    if (jssStyles) {\n      jssStyles.parentNode.removeChild(jssStyles);\n    }\n  }, []);\n\n  return (\n    <ThemeProvider theme={theme}>\n      <App />\n    </ThemeProvider>\n  );\n}\n\nReactDOM.hydrate(<Main />, document.querySelector('#root'));\n```\n\n## 参考实现\n\n您可以在 [GitHub 存储库中](https://github.com/mui-org/material-ui)的 [`/examples`](https://github.com/mui-org/material-ui/tree/master/examples) 的文件夹下面，找到我们托管的不同的范例项目：\n\n- [本教程的参考实现](https://github.com/mui-org/material-ui/tree/master/examples/ssr)\n- [Gatsby](https://github.com/mui-org/material-ui/tree/master/examples/gatsby)\n- [Next.js](https://github.com/mui-org/material-ui/tree/master/examples/nextjs)\n\n## 故障排除（Troubleshooting）\n\n查看我们的常见问题解答答案：[我的应用程序无法在服务器上正确地渲染](/getting-started/faq/#my-app-doesnt-render-correctly-on-the-server) 。"},"8rfX":function(e,n){e.exports="# Server Rendering\n\n<p class=\"description\">The most common use case for server-side rendering is to handle the initial render when a user (or search engine crawler) first requests your app.</p>\n\nWhen the server receives the request, it renders the required component(s) into an HTML string, and then sends it as a response to the client.\nFrom that point on, the client takes over rendering duties.\n\n## Material-UI on the server\n\nMaterial-UI was designed from the ground-up with the constraint of rendering on the server, but it's up to you to make sure it's correctly integrated.\nIt's important to provide the page with the required CSS, otherwise the page will render with just the HTML then wait for the CSS to be injected by the client, causing it to flicker (FOUC).\nTo inject the style down to the client, we need to:\n\n1. Create a fresh, new [`ServerStyleSheets`](/styles/api/#serverstylesheets) instance on every request.\n2. Render the React tree with the server-side collector.\n3. Pull the CSS out.\n4. Pass the CSS along to the client.\n\nOn the client side, the CSS will be injected a second time before removing the server-side injected CSS.\n\n## Setting Up\n\nIn the following recipe, we are going to look at how to set up server-side rendering.\n\n### The theme\n\nWe create a theme that will be shared between the client and the server.\n\n`theme.js`\n\n```js\nimport { createMuiTheme } from '@material-ui/core/styles';\nimport red from '@material-ui/core/colors/red';\n\n// Create a theme instance.\nconst theme = createMuiTheme({\n  palette: {\n    primary: {\n      main: '#556cd6',\n    },\n    secondary: {\n      main: '#19857b',\n    },\n    error: {\n      main: red.A400,\n    },\n    background: {\n      default: '#fff',\n    },\n  },\n});\n\nexport default theme;\n```\n\n### The server-side\n\nThe following is the outline for what our server-side is going to look like.\nWe are going to set up an [Express middleware](https://expressjs.com/en/guide/using-middleware.html) using [app.use](https://expressjs.com/en/api.html) to handle all requests that come in to our server.\nIf you're unfamiliar with Express or middleware, just know that our handleRender function will be called every time the server receives a request.\n\n`server.js`\n\n```js\nimport express from 'express';\n\n// We are going to fill these out in the sections to follow.\nfunction renderFullPage(html, css) {\n  /* ... */\n}\n\nfunction handleRender(req, res) {\n  /* ... */\n}\n\nconst app = express();\n\n// This is fired every time the server-side receives a request.\napp.use(handleRender);\n\nconst port = 3000;\napp.listen(port);\n```\n\n### Handling the Request\n\nThe first thing that we need to do on every request is create a new `ServerStyleSheets`.\n\nWhen rendering, we will wrap `App`, our root component,\ninside a [`StylesProvider`](/styles/api/#stylesprovider) and [`ThemeProvider`](/styles/api/#themeprovider) to make the style configuration and the `theme` available to all components in the component tree.\n\nThe key step in server-side rendering is to render the initial HTML of our component **before** we send it to the client side. To do this, we use [ReactDOMServer.renderToString()](https://reactjs.org/docs/react-dom-server.html).\n\nWe then get the CSS from our `sheets` using `sheets.toString()`.\nWe will see how this is passed along in our `renderFullPage` function.\n\n```jsx\nimport express from 'express';\nimport React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport { ServerStyleSheets, ThemeProvider } from '@material-ui/styles';\nimport App from './App';\nimport theme from './theme';\n\nfunction handleRender(req, res) {\n  const sheets = new ServerStyleSheets();\n\n  // Render the component to a string.\n  const html = ReactDOMServer.renderToString(\n    sheets.collect(\n      <ThemeProvider theme={theme}>\n        <App />\n      </ThemeProvider>,\n    ),\n  );\n\n  // Grab the CSS from our sheets.\n  const css = sheets.toString();\n\n  // Send the rendered page back to the client.\n  res.send(renderFullPage(html, css));\n}\n\nconst app = express();\n\napp.use('/build', express.static('build'));\n\n// This is fired every time the server-side receives a request.\napp.use(handleRender);\n\nconst port = 3000;\napp.listen(port);\n```\n\n### Inject Initial Component HTML and CSS\n\nThe final step on the server-side is to inject our initial component HTML and CSS into a template to be rendered on the client side.\n\n```js\nfunction renderFullPage(html, css) {\n  return `\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>My page</title>\n        <style id=\"jss-server-side\">${css}</style>\n      </head>\n      <body>\n        <div id=\"root\">${html}</div>\n      </body>\n    </html>\n  `;\n}\n```\n\n### The Client Side\n\nThe client side is straightforward. All we need to do is remove the server-side generated CSS.\nLet's take a look at our client file:\n\n`client.js`\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { ThemeProvider } from '@material-ui/styles';\nimport App from './App';\nimport theme from './theme';\n\nfunction Main() {\n  React.useEffect(() => {\n    const jssStyles = document.querySelector('#jss-server-side');\n    if (jssStyles) {\n      jssStyles.parentNode.removeChild(jssStyles);\n    }\n  }, []);\n\n  return (\n    <ThemeProvider theme={theme}>\n      <App />\n    </ThemeProvider>\n  );\n}\n\nReactDOM.hydrate(<Main />, document.querySelector('#root'));\n```\n\n## Reference implementations\n\nWe host different reference implementations which you can find in the [GitHub repository](https://github.com/mui-org/material-ui) under the [`/examples`](https://github.com/mui-org/material-ui/tree/master/examples) folder:\n\n- [The reference implementation of this tutorial](https://github.com/mui-org/material-ui/tree/master/examples/ssr)\n- [Gatsby](https://github.com/mui-org/material-ui/tree/master/examples/gatsby)\n- [Next.js](https://github.com/mui-org/material-ui/tree/master/examples/nextjs)\n\n## Troubleshooting\n\nCheck out our FAQ answer: [My App doesn't render correctly on the server](/getting-started/faq/#my-app-doesnt-render-correctly-on-the-server).\n"},HVuC:function(e,n){e.exports="# crwdns96470:0crwdne96470:0\n\n<p class=\"description\">crwdns96472:0crwdne96472:0</p>\n\ncrwdns96474:0crwdne96474:0 crwdns96476:0crwdne96476:0\n\n## crwdns96478:0crwdne96478:0\n\ncrwdns96480:0crwdne96480:0 crwdns96482:0crwdne96482:0 crwdns96484:0crwdne96484:0\n\n1. crwdns96486:0crwdne96486:0\n2. crwdns96488:0crwdne96488:0\n3. crwdns96490:0crwdne96490:0\n4. crwdns96492:0crwdne96492:0\n\ncrwdns96494:0crwdne96494:0\n\n## crwdns96496:0crwdne96496:0\n\ncrwdns96498:0crwdne96498:0\n\n### crwdns96500:0crwdne96500:0\n\ncrwdns96502:0crwdne96502:0\n\n`crwdns96504:0crwdne96504:0`\n\n```js\ncrwdns96506:0{ createMuiTheme }crwdne96506:0\ncrwdns96508:0{\n      main: '#556cd6',\n    }crwdnd96508:0{\n      main: '#19857b',\n    }crwdnd96508:0{\n      main: red.A400,\n    }crwdnd96508:0{\n      default: '#fff',\n    }crwdne96508:0\n```\n\n### crwdns96510:0crwdne96510:0\n\ncrwdns96512:0crwdne96512:0 crwdns96514:0crwdne96514:0 crwdns96516:0crwdne96516:0\n\n`crwdns96518:0crwdne96518:0`\n\n```js\ncrwdns96520:0crwdne96520:0\ncrwdns96522:0crwdne96522:0 crwdns96524:0crwdne96524:0 crwdns96526:0crwdne96526:0\ncrwdns96528:0crwdne96528:0\n```\n\n### crwdns96530:0crwdne96530:0\n\ncrwdns96532:0crwdne96532:0\n\ncrwdns96534:0crwdne96534:0\n\ncrwdns96536:0crwdne96536:0 crwdns96538:0crwdne96538:0\n\ncrwdns96540:0crwdne96540:0 crwdns96542:0crwdne96542:0\n\n```jsx\ncrwdns96544:0{ ServerStyleSheets, ThemeProvider }crwdne96544:0\n  crwdns96546:0{theme}crwdne96546:0\n  crwdns96548:0crwdne96548:0\n  crwdns96550:0crwdne96550:0\ncrwdns96552:0crwdne96552:0\n```\n\n### crwdns96554:0crwdne96554:0\n\ncrwdns96556:0crwdne96556:0\n\n```js\ncrwdns96558:0${css}crwdnd96558:0${html}crwdne96558:0\n```\n\n### crwdns96560:0crwdne96560:0\n\ncrwdns96562:0crwdne96562:0 crwdns96564:0crwdne96564:0 crwdns96566:0crwdne96566:0\n\n`crwdns96568:0crwdne96568:0`\n\n```jsx\ncrwdns96570:0{ ThemeProvider }crwdnd96570:0{theme}crwdne96570:0\n```\n\n## crwdns96572:0crwdne96572:0\n\ncrwdns96574:0crwdne96574:0\n\n- [crwdns96578:0crwdne96578:0](crwdns96576:0crwdne96576:0)\n- [crwdns96582:0crwdne96582:0](crwdns96580:0crwdne96580:0)\n- [crwdns96586:0crwdne96586:0](crwdns96584:0crwdne96584:0)\n\n## crwdns96588:0crwdne96588:0\n\ncrwdns96590:0crwdne96590:0"},WFiQ:function(e,n){e.exports="# サーバーサイドレンダリング\n\n<p class=\"description\">The most common use case for server-side rendering is to handle the initial render when a user (or search engine crawler) first requests your app.</p>\n\nWhen the server receives the request, it renders the required component(s) into an HTML string, and then sends it as a response to the client. From that point on, the client takes over rendering duties.\n\n## Material-UI on the server\n\nMaterial-UI was designed from the ground-up with the constraint of rendering on the server, but it's up to you to make sure it's correctly integrated. It's important to provide the page with the required CSS, otherwise the page will render with just the HTML then wait for the CSS to be injected by the client, causing it to flicker (FOUC). To inject the style down to the client, we need to:\n\n1. Create a fresh, new [`ServerStyleSheets`](/styles/api/#serverstylesheets) instance on every request.\n2. Render the React tree with the server-side collector.\n3. Pull the CSS out.\n4. Pass the CSS along to the client.\n\nOn the client side, the CSS will be injected a second time before removing the server-side injected CSS.\n\n## Setting Up\n\nIn the following recipe, we are going to look at how to set up server-side rendering.\n\n### The theme\n\nWe create a theme that will be shared between the client and the server.\n\n`theme.js`\n\n```js\nimport { createMuiTheme } from '@material-ui/core/styles';\nimport red from '@material-ui/core/colors/red';\n\n// Create a theme instance.\nconst theme = createMuiTheme({\n  palette: {\n    primary: {\n      main: '#556cd6',\n    },\n    secondary: {\n      main: '#19857b',\n    },\n    error: {\n      main: red.A400,\n    },\n    background: {\n      default: '#fff',\n    },\n  },\n});\n\nexport default theme;\n```\n\n### The server-side\n\nThe following is the outline for what our server-side is going to look like. We are going to set up an [Express middleware](https://expressjs.com/en/guide/using-middleware.html) using [app.use](https://expressjs.com/en/api.html) to handle all requests that come in to our server. If you're unfamiliar with Express or middleware, just know that our handleRender function will be called every time the server receives a request.\n\n`server.js`\n\n```js\nimport express from 'express';\n\n// We are going to fill these out in the sections to follow.\nfunction renderFullPage(html, css) {\n  /* ... */\n}\n\nfunction handleRender(req, res) {\n  /* ... */\n}\n\nconst app = express();\n\n// Isso é acionado toda vez que o servidor recebe uma solicitação.\napp.use(handleRender);\n\nconst port = 3000;\napp.listen(port);\n```\n\n### Handling the Request\n\nThe first thing that we need to do on every request is create a new `ServerStyleSheets`.\n\nWhen rendering, we will wrap `App`, our root component, inside a [`StylesProvider`](/styles/api/#stylesprovider) and [`ThemeProvider`](/styles/api/#themeprovider) to make the style configuration and the `theme` available to all components in the component tree.\n\nThe key step in server-side rendering is to render the initial HTML of our component **before** we send it to the client side. To do this, we use [ReactDOMServer.renderToString()](https://reactjs.org/docs/react-dom-server.html).\n\nWe then get the CSS from our `sheets` using `sheets.toString()`. We will see how this is passed along in our `renderFullPage` function.\n\n```jsx\nimport express from 'express';\nimport React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport { ServerStyleSheets, ThemeProvider } from '@material-ui/styles';\nimport App from './App';\nimport theme from './theme';\n\nfunction handleRender(req, res) {\n  const sheets = new ServerStyleSheets();\n\n  // Render the component to a string.\n  const html = ReactDOMServer.renderToString(\n    sheets.collect(\n      <ThemeProvider theme={theme}>\n        <App />\n      </ThemeProvider>,\n    ),\n  );\n\n  // Grab the CSS from our sheets.\n  const css = sheets.toString();\n\n  // Send the rendered page back to the client.\n  res.send(renderFullPage(html, css));\n}\n\nconst app = express();\n\napp.use('/build', express.static('build'));\n\n// This is fired every time the server-side receives a request.\napp.use(handleRender);\n\nconst port = 3000;\napp.listen(port);\n```\n\n### Inject Initial Component HTML and CSS\n\nThe final step on the server-side is to inject our initial component HTML and CSS into a template to be rendered on the client side.\n\n```js\nfunction renderFullPage(html, css) {\n  return `\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>My page</title>\n        <style id=\"jss-server-side\">${css}</style>\n      </head>\n      <body>\n        <div id=\"root\">${html}</div>\n      </body>\n    </html>\n  `;\n}\n```\n\n### The Client Side\n\nThe client side is straightforward. All we need to do is remove the server-side generated CSS. Let's take a look at our client file:\n\n`client.js`\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { ThemeProvider } from '@material-ui/styles';\nimport App from './App';\nimport theme from './theme';\n\nfunction Main() {\n  React.useEffect(() => {\n    const jssStyles = document.querySelector('#jss-server-side');\n    if (jssStyles) {\n      jssStyles.parentNode.removeChild(jssStyles);\n    }\n  }, []);\n\n  return (\n    <ThemeProvider theme={theme}>\n      <App />\n    </ThemeProvider>\n  );\n}\n\nReactDOM.hydrate(<Main />, document.querySelector('#root'));\n```\n\n## Reference implementations\n\nWe host different reference implementations which you can find in the [GitHub repository](https://github.com/mui-org/material-ui) under the [`/examples`](https://github.com/mui-org/material-ui/tree/master/examples) folder:\n\n- [The reference implementation of this tutorial](https://github.com/mui-org/material-ui/tree/master/examples/ssr)\n- [Gatsby](https://github.com/mui-org/material-ui/tree/master/examples/gatsby)\n- [Next.js](https://github.com/mui-org/material-ui/tree/master/examples/nextjs)\n\n## Troubleshooting\n\nCheck out our FAQ answer: [My App doesn't render correctly on the server](/getting-started/faq/#my-app-doesnt-render-correctly-on-the-server)."},YSBL:function(e,n){e.exports="# Серверная отрисовка\n\n<p class=\"description\">Наиболее распространенный вариант использования для серверной отрисовки - это использовать начальную отрисовку, когда пользователь (или поисковой движок) впервые запрашивает ваше приложение.</p>\n\nКогда сервер получает запрос, он отрисовывает необходимые компоненты в HTML строк, а затем отправляет ее как ответ клиенту. С этого момента клиент берет на себя обязанности по отрисовке.\n\n## Material-UI on the server\n\nMaterial-UI was designed from the ground-up with the constraint of rendering on the server, but it's up to you to make sure it's correctly integrated. It's important to provide the page with the required CSS, otherwise the page will render with just the HTML then wait for the CSS to be injected by the client, causing it to flicker (FOUC). Чтобы добавить стили на клиент, вам необходимо:\n\n1. Create a fresh, new [`ServerStyleSheets`](/styles/api/#serverstylesheets) instance on every request.\n2. Render the React tree with the server-side collector.\n3. Pull the CSS out.\n4. Передать CSS клиенту.\n\nНа стороне клиента CSS будет добавлен второй раз перед удалением добавленного сервером CSS.\n\n## Настройка\n\nВ следующем рецепте мы рассмотрим, как настроить серверную отрисовку.\n\n### The theme\n\nWe create a theme that will be shared between the client and the server.\n\n`theme.js`\n\n```js\nimport { createMuiTheme } from '@material-ui/core/styles';\nimport red from '@material-ui/core/colors/red';\n\n// Create a theme instance.\nconst theme = createMuiTheme({\n  palette: {\n    primary: {\n      main: '#556cd6',\n    },\n    secondary: {\n      main: '#19857b',\n    },\n    error: {\n      main: red.A400,\n    },\n    background: {\n      default: '#fff',\n    },\n  },\n});\n\nexport default theme;\n```\n\n### The server-side\n\nНиже приведено описание того, как наша сторона сервера будет выглядеть. Мы настраиваем [Express middleware](https://expressjs.com/en/guide/using-middleware.html), используя [app.use](https://expressjs.com/en/api.html), чтобы обработать все запросы, которые приходят на наш сервер. Если вы не знакомы с Express или middleware, просто знайте, что наша функция handleRender будет вызвана каждый раз, когда сервер получает запрос.\n\n`server.js`\n\n```js\nimport express from 'express';\n\n// We are going to fill these out in the sections to follow.\nfunction renderFullPage(html, css) {\n  /* ... */\n}\n\nfunction handleRender(req, res) {\n  /* ... */\n}\n\nconst app = express();\n\n// Isso é acionado toda vez que o servidor recebe uma solicitação.\napp.use(handleRender);\n\nconst port = 3000;\napp.listen(port);\n```\n\n### Обработка запроса\n\nThe first thing that we need to do on every request is create a new `ServerStyleSheets`.\n\nWhen rendering, we will wrap `App`, our root component, inside a [`StylesProvider`](/styles/api/#stylesprovider) and [`ThemeProvider`](/styles/api/#themeprovider) to make the style configuration and the `theme` available to all components in the component tree.\n\nThe key step in server-side rendering is to render the initial HTML of our component **before** we send it to the client side. To do this, we use [ReactDOMServer.renderToString()](https://reactjs.org/docs/react-dom-server.html).\n\nWe then get the CSS from our `sheets` using `sheets.toString()`. We will see how this is passed along in our `renderFullPage` function.\n\n```jsx\nimport express from 'express';\nimport React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport { ServerStyleSheets, ThemeProvider } from '@material-ui/styles';\nimport App from './App';\nimport theme from './theme';\n\nfunction handleRender(req, res) {\n  const sheets = new ServerStyleSheets();\n\n  // Render the component to a string.\n  const html = ReactDOMServer.renderToString(\n    sheets.collect(\n      <ThemeProvider theme={theme}>\n        <App />\n      </ThemeProvider>,\n    ),\n  );\n\n  // Grab the CSS from our sheets.\n  const css = sheets.toString();\n\n  // Send the rendered page back to the client.\n  res.send(renderFullPage(html, css));\n}\n\nconst app = express();\n\napp.use('/build', express.static('build'));\n\n// This is fired every time the server-side receives a request.\napp.use(handleRender);\n\nconst port = 3000;\napp.listen(port);\n```\n\n### Inject Initial Component HTML and CSS\n\nThe final step on the server-side is to inject our initial component HTML and CSS into a template to be rendered on the client side.\n\n```js\nfunction renderFullPage(html, css) {\n  return `\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>My page</title>\n        <style id=\"jss-server-side\">${css}</style>\n      </head>\n      <body>\n        <div id=\"root\">${html}</div>\n      </body>\n    </html>\n  `;\n}\n```\n\n### The Client Side\n\nThe client side is straightforward. All we need to do is remove the server-side generated CSS. Let's take a look at our client file:\n\n`client.js`\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { ThemeProvider } from '@material-ui/styles';\nimport App from './App';\nimport theme from './theme';\n\nfunction Main() {\n  React.useEffect(() => {\n    const jssStyles = document.querySelector('#jss-server-side');\n    if (jssStyles) {\n      jssStyles.parentNode.removeChild(jssStyles);\n    }\n  }, []);\n\n  return (\n    <ThemeProvider theme={theme}>\n      <App />\n    </ThemeProvider>\n  );\n}\n\nReactDOM.hydrate(<Main />, document.querySelector('#root'));\n```\n\n## Reference implementations\n\nWe host different reference implementations which you can find in the [GitHub repository](https://github.com/mui-org/material-ui) under the [`/examples`](https://github.com/mui-org/material-ui/tree/master/examples) folder:\n\n- [The reference implementation of this tutorial](https://github.com/mui-org/material-ui/tree/master/examples/ssr)\n- [Gatsby](https://github.com/mui-org/material-ui/tree/master/examples/gatsby)\n- [Next.js](https://github.com/mui-org/material-ui/tree/master/examples/nextjs)\n\n## Troubleshooting\n\nCheck out our FAQ answer: [My App doesn't render correctly on the server](/getting-started/faq/#my-app-doesnt-render-correctly-on-the-server)."},ZYUm:function(e,n){function r(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}r.keys=function(){return[]},r.resolve=r,e.exports=r,r.id="ZYUm"},ZxAm:function(e,n){e.exports="# Server-Rendering\n\n<p class=\"description\">Der gebräuchlichste Anwendungsfall für das serverseitige Rendern ist das anfängliche Rendern, wenn ein Benutzer (oder Suchmaschinen-Crawler) Ihre App zum ersten Mal anfordert.</p>\n\nWenn der Server die Anforderung empfängt, stellt er die erforderlichen Komponenten in einem HTML-String dar und sendet sie als Antwort an den Client. Ab diesem Zeitpunkt übernimmt der Client die Rendering-Aufgaben.\n\n## Material-UI auf dem Server\n\nDie Material-UI wurde von Grund auf mit der Möglichkeit des Renderns auf dem Server entwickelt. Sie müssen jedoch sicherstellen, dass sie korrekt integriert ist. Es ist wichtig, die Seite mit dem erforderlichen CSS zu versehen, andernfalls wird die Seite nur mit HTM-Code gerendert und dann darauf gewartet, dass der Client das CSS einfügt was zu flackern führt (FOUC). Um den Stil in den Client zu injizieren, müssen wir:\n\n1. Eine neue [`ServerStyleSheets`](/styles/api/#serverstylesheets) Instanz bei jede Anfrage erstellen.\n2. Den React-Baum mit dem serverseitigen Collector rendern.\n3. Das CSS herausziehen.\n4. Das CSS zum Client weiterleiten.\n\nAuf der Clientseite wird das CSS ein zweites Mal eingefügt, bevor das serverseitige injizierte CSS entfernt wird.\n\n## Installation\n\nIm folgenden Rezept wird beschrieben, wie das serverseitige Rendering eingerichtet wird.\n\n### Das Theme\n\nWir erstellen ein Theme, das vom Client und vom Server gemeinsam genutzt wird.\n\n`theme.js`\n\n```js\nimport { createMuiTheme } from '@material-ui/core/styles';\nimport red from '@material-ui/core/colors/red';\n\n// Erstellen Sie eine Theme-Instanz.\nconst theme = createMuiTheme({\n  palette: {\n    primary: {\n      main: '#556cd6',\n    },\n    secondary: {\n      main: '#19857b',\n    },\n    error: {\n      main: red.A400,\n    },\n    background: {\n      default: '#fff',\n    },\n  },\n});\n\nexport default theme;\n```\n\n### Die Server-Seite\n\nIm Folgenden wird beschrieben, wie unsere Serverseite aussehen wird. Wir werden eine[ Express-Middleware](https://expressjs.com/en/guide/using-middleware.html) mit [ app.use ](https://expressjs.com/en/api.html) einrichten, um alle Anfragen zu bearbeiten, die auf unserem Server eingehen. Wenn Sie mit Express oder Middleware nicht vertraut sind, sollten Sie wissen, dass unsere handleRender-Funktion jedes Mal aufgerufen wird, wenn der Server eine Anfrage erhält.\n\n`server.js`\n\n```js\nimport express from 'express';\n\n// Diese werden wir in den folgenden Abschnitten ausfüllen.\nfunction renderFullPage(html, css) {\n  /* ... */\n}\n\nfunction handleRender(req, res) {\n  /* ... */\n}\n\nconst app = express();\n\n// Isso é acionado toda vez que o servidor recebe uma solicitação.\napp.use(handleRender);\n\nconst port = 3000;\napp.listen(port);\n```\n\n### Verarbeiten der Anfrage\n\nAls Erstes müssen wir bei jeder Anfrage ein neues `ServerStyleSheets` erstellen.\n\nBeim Rendern wickeln wir die `App`, unsere Wurzelkomponente, in einem [`StylesProvider`](/styles/api/#stylesprovider) und [`ThemeProvider`](/styles/api/#themeprovider) ein, um die Stilkonfiguration und das `Theme` für alle Komponenten im Komponentenbaum verfügbar zu machen.\n\nDer wichtigste Schritt beim serverseitigen Rendern ist das Rendern des ursprünglichen HTM-Codes unserer Komponente **bevor** wir es an den Kunden senden. Dazu verwenden wir [ReactDOMServer.renderToString()](https://reactjs.org/docs/react-dom-server.html).\n\nWir erhalten dann das CSS aus unsere `Sheets` mit `sheets.toString()`. Wir werden sehen, wie dies in unserer ` enderFullPage`-Funktion weitergegeben wird.\n\n```jsx\nimport express from 'express';\nimport React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport { ServerStyleSheets, ThemeProvider } from '@material-ui/styles';\nimport App from './App';\nimport theme from './theme';\n\nfunction handleRender(req, res) {\n  const sheets = new ServerStyleSheets();\n\n  // Rendern Sie die Komponente in einen String.\n  const html = ReactDOMServer.renderToString(\n    sheets.collect(\n      <ThemeProvider theme={theme}>\n        <App />\n      </ThemeProvider>,\n    ),\n  );\n\n  // Entnahme des CSS aus dem Sheet.\n  const css = sheets.toString();\n\n  // Zurücksenden der gerenderten Seite an den Client.\n  res.send(renderFullPage(html, css));\n}\n\nconst app = express();\n\napp.use('/build', express.static('build'));\n\n// Dies wird jedes Mal ausgelöst, wenn der Server eine Anfrage erhält.\napp.use(handleRender);\n\nconst port = 3000;\napp.listen(port);\n```\n\n### Injizieren der ursprüngliche HTML Komponente und CSS\n\nDer letzte Schritt auf der Serverseite ist das Einfügen unserer ursprünglichen HTML Komponente und CSS in eine Vorlage, die auf der Clientseite gerendert werden soll.\n\n```js\nfunction renderFullPage(html, css) {\n  return `\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>My page</title>\n        <style id=\"jss-server-side\">${css}</style>\n      </head>\n      <body>\n        <div id=\"root\">${html}</div>\n      </body>\n    </html>\n  `;\n}\n```\n\n### Die Client-Seite\n\nDie Client-Seite ist unkompliziert. Wir müssen nur das serverseitig erzeugte CSS entfernen. Werfen wir einen Blick auf unsere Client Datei:\n\n`client.js`\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { ThemeProvider } from '@material-ui/styles';\nimport App from './App';\nimport theme from './theme';\n\nfunction Main() {\n  React.useEffect(() => {\n    const jssStyles = document.querySelector('#jss-server-side');\n    if (jssStyles) {\n      jssStyles.parentNode.removeChild(jssStyles);\n    }\n  }, []);\n\n  return (\n    <ThemeProvider theme={theme}>\n      <App />\n    </ThemeProvider>\n  );\n}\n\nReactDOM.hydrate(<Main />, document.querySelector('#root'));\n```\n\n## Referenzimplementierungen\n\nWir bieten verschiedene Referenzimplementierungen an, die Sie im [GitHub-Repository](https://github.com/mui-org/material-ui) finden können unter dem [`/examples`](https://github.com/mui-org/material-ui/tree/master/examples) Ordner:\n\n- [Die Referenzimplementierung dieses Tutorials](https://github.com/mui-org/material-ui/tree/master/examples/ssr)\n- [Gatsby](https://github.com/mui-org/material-ui/tree/master/examples/gatsby)\n- [Next.js](https://github.com/mui-org/material-ui/tree/master/examples/nextjs)\n\n## Problemlösungen\n\nLesen Sie unsere Antworten auf häufig gestellte Fragen: [Meine App wird auf dem Server nicht richtig gerendert](/getting-started/faq/#my-app-doesnt-render-correctly-on-the-server)."},aOOu:function(e,n,r){"use strict";r.r(n),r.d(n,"default",function(){return m});var t=r("mXGw"),s=r.n(t),i=r("e+1t"),o=r("qyn3"),a=r("ZYUm"),d=s.a.createElement(i.a,{req:o,reqSource:a,reqPrefix:"pages/guides/server-rendering"});function m(){return d}},aeaA:function(e,n){e.exports="# Renderização no servidor\n\n<p class=\"description\">O caso de uso mais comum para a renderização do lado do servidor, é manipular a renderização inicial quando um usuário (ou rastreador do mecanismo de pesquisa) solicita sua aplicação.</p>\n\nQuando o servidor recebe a solicitação, ele renderiza o componente(s) requerido em uma cadeia HTML e o envia como uma resposta ao cliente. A partir desse momento, o cliente assume as funções de renderização.\n\n## Material-UI no servidor\n\nO Material-UI foi desenhado da base com as limitações de renderizar no servidor, mas você pode se certificar que será integrado corretamente. É importante fornecer a página com o CSS necessário, caso contrário a página irá renderizar somente o HTML até o CSS ser injetado pelo cliente, causando uma tremulação (FOUC). Para injetar o estilo no cliente, precisamos:\n\n1. Cria uma instância nova e fresca do [`ServerStyleSheets`](/styles/api/#serverstylesheets) em cada requisição.\n2. Renderize a árvore React com o coletor do lado do servidor.\n3. Puxe o CSS para fora.\n4. Passe o CSS junto ao cliente.\n\nNo lado do cliente, o CSS será injetado uma segunda vez antes de remover o CSS injetado no lado do servidor.\n\n## Configurando\n\nNa receita a seguir, vamos ver como configurar a renderização do lado do servidor.\n\n### O tema\n\nCriamos um tema que será compartilhado entre o cliente e o servidor.\n\n`theme.js`\n\n```js\nimport { createMuiTheme } from '@material-ui/core/styles';\nimport red from '@material-ui/core/colors/red';\n\n// Cria a instância do tema.\nconst theme = createMuiTheme({\n  palette: {\n    primary: {\n      main: '#556cd6',\n    },\n    secondary: {\n      main: '#19857b',\n    },\n    error: {\n      main: red.A400,\n    },\n    background: {\n      default: '#fff',\n    },\n  },\n});\n\nexport default theme;\n```\n\n### O lado do servidor\n\nO seguinte é o esboço para o aspecto que o nosso servidor deve olhar. Vamos montar um [middleware Express](https://expressjs.com/en/guide/using-middleware.html) usando [app.use](https://expressjs.com/en/api.html) para lidar com todas as requisições que chegam ao nosso servidor. Se você não estiver familiarizado com o Express ou o middleware, saiba apenas, que nossa função handleRender será chamada toda vez que o servidor receber uma requisição.\n\n`server.js`\n\n```js\nimport express from 'express';\n\n// Vamos preenchê-las nas seções a seguir.\nfunction renderFullPage(html, css) {\n  /* ... */\n}\n\nfunction handleRender(req, res) {\n  /* ... */\n}\n\nconst app = express();\n\n// Isso é acionado toda vez que o servidor recebe uma solicitação.\napp.use(handleRender);\n\nconst port = 3000;\napp.listen(port);\n```\n\n### Manipulando a requisição\n\nA primeira coisa que precisamos fazer em cada solicitação é criar um novo `ServerStyleSheets`.\n\nQuando renderizando, vamos encapsular `App`, nosso componente raiz, dentro de um [`StylesProvider`](/styles/api/#stylesprovider) e [` ThemeProvider`](/styles/api/#themeprovider) para tornar a configuração de estilo e o ` theme` disponíveis para todos os componentes na árvore de componentes.\n\nA etapa principal na renderização do lado do servidor, é renderizar o HTML inicial de nosso componente **antes** de nós enviarmos para o lado do cliente. Para fazer isso, usamos [ReactDOMServer.renderToString()](https://reactjs.org/docs/react-dom-server.html).\n\nEm seguida, obtemos o CSS de nossas `folhas` usando `sheets.toString()`. Vamos ver como isso é passado em nossa função `renderFullPage`.\n\n```jsx\nimport express from 'express';\nimport React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport { ServerStyleSheets, ThemeProvider } from '@material-ui/styles';\nimport App from './App';\nimport theme from './theme';\n\nfunction handleRender(req, res) {\n  const sheets = new ServerStyleSheets();\n\n  // Renderiza o componente para string.\n  const html = ReactDOMServer.renderToString(\n    sheets.collect(\n      <ThemeProvider theme={theme}>\n        <App />\n      </ThemeProvider>,\n    ),\n  );\n\n  // Pega o CSS de nossas folhas.\n  const css = sheets.toString();\n\n  // Envia a página renderizada de volta ao cliente.\n  res.send(renderFullPage(html, css));\n}\n\nconst app = express();\n\napp.use('/build', express.static('build'));\n\n// Isso é acionado toda vez que o servidor recebe uma solicitação.\napp.use(handleRender);\n\nconst port = 3000;\napp.listen(port);\n```\n\n### Injetar Componente Inicial HTML e CSS\n\nA etapa final no lado do servidor é injetar nosso componente HTML e CSS inicial em um modelo a ser renderizado no lado do cliente.\n\n```js\nfunction renderFullPage(html, css) {\n  return `\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>Minha página</title>\n        <style id=\"jss-server-side\">${css}</style>\n      </head>\n      <body>\n        <div id=\"root\">${html}</div>\n      </body>\n    </html>\n  `;\n}\n```\n\n### O lado do cliente\n\nO lado do cliente é direto. Tudo o que precisamos fazer é remover o CSS gerado no lado do servidor. Vamos dar uma olhada no nosso arquivo de cliente:\n\n`client.js`\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { ThemeProvider } from '@material-ui/styles';\nimport App from './App';\nimport theme from './theme';\n\nfunction Main() {\n  React.useEffect(() => {\n    const jssStyles = document.querySelector('#jss-server-side');\n    if (jssStyles) {\n      jssStyles.parentNode.removeChild(jssStyles);\n    }\n  }, []);\n\n  return (\n    <ThemeProvider theme={theme}>\n      <App />\n    </ThemeProvider>\n  );\n}\n\nReactDOM.hydrate(<Main />, document.querySelector('#root'));\n```\n\n## Implementações de referência\n\nNós hospedamos diferentes implementações de referência que você pode encontrar no [repositório GitHub](https://github.com/mui-org/material-ui) sob a pasta o [`/examples`](https://github.com/mui-org/material-ui/tree/master/examples):\n\n- [A implementação de referência deste tutorial](https://github.com/mui-org/material-ui/tree/master/examples/ssr)\n- [Gatsby](https://github.com/mui-org/material-ui/tree/master/examples/gatsby)\n- [Next.js](https://github.com/mui-org/material-ui/tree/master/examples/nextjs)\n\n## Resolução de problemas\n\nConfira nossa resposta FAQ: [Minha aplicação não é renderizada corretamente no servidor](/getting-started/faq/#my-app-doesnt-render-correctly-on-the-server)."},qyn3:function(e,n,r){var t={"./server-rendering-aa.md":"HVuC","./server-rendering-de.md":"ZxAm","./server-rendering-es.md":"uIbf","./server-rendering-fr.md":"sea+","./server-rendering-ja.md":"WFiQ","./server-rendering-pt.md":"aeaA","./server-rendering-ru.md":"YSBL","./server-rendering-zh.md":"634K","./server-rendering.md":"8rfX"};function s(e){var n=i(e);return r(n)}function i(e){var n=t[e];if(!(n+1)){var r=new Error("Cannot find module '"+e+"'");throw r.code="MODULE_NOT_FOUND",r}return n}s.keys=function(){return Object.keys(t)},s.resolve=i,e.exports=s,s.id="qyn3"},"sea+":function(e,n){e.exports="# Rendu serveur\n\n<p class=\"description\">The most common use case for server-side rendering is to handle the initial render when a user (or search engine crawler) first requests your app.</p>\n\nWhen the server receives the request, it renders the required component(s) into an HTML string, and then sends it as a response to the client. From that point on, the client takes over rendering duties.\n\n## Material-UI on the server\n\nMaterial-UI was designed from the ground-up with the constraint of rendering on the server, but it's up to you to make sure it's correctly integrated. It's important to provide the page with the required CSS, otherwise the page will render with just the HTML then wait for the CSS to be injected by the client, causing it to flicker (FOUC). To inject the style down to the client, we need to:\n\n1. Create a fresh, new [`ServerStyleSheets`](/styles/api/#serverstylesheets) instance on every request.\n2. Render the React tree with the server-side collector.\n3. Pull the CSS out.\n4. Pass the CSS along to the client.\n\nOn the client side, the CSS will be injected a second time before removing the server-side injected CSS.\n\n## Mise en place\n\nIn the following recipe, we are going to look at how to set up server-side rendering.\n\n### The theme\n\nWe create a theme that will be shared between the client and the server.\n\n`theme.js`\n\n```js\nimport { createMuiTheme } from '@material-ui/core/styles';\nimport red from '@material-ui/core/colors/red';\n\n// Create a theme instance.\nconst theme = createMuiTheme({\n  palette: {\n    primary: {\n      main: '#556cd6',\n    },\n    secondary: {\n      main: '#19857b',\n    },\n    error: {\n      main: red.A400,\n    },\n    background: {\n      default: '#fff',\n    },\n  },\n});\n\nexport default theme;\n```\n\n### The server-side\n\nThe following is the outline for what our server-side is going to look like. We are going to set up an [Express middleware](https://expressjs.com/en/guide/using-middleware.html) using [app.use](https://expressjs.com/en/api.html) to handle all requests that come in to our server. If you're unfamiliar with Express or middleware, just know that our handleRender function will be called every time the server receives a request.\n\n`server.js`\n\n```js\nimport express from 'express';\n\n// We are going to fill these out in the sections to follow.\nfunction renderFullPage(html, css) {\n  /* ... */\n}\n\nfunction handleRender(req, res) {\n  /* ... */\n}\n\nconst app = express();\n\n// Isso é acionado toda vez que o servidor recebe uma solicitação.\napp.use(handleRender);\n\nconst port = 3000;\napp.listen(port);\n```\n\n### Handling the Request\n\nThe first thing that we need to do on every request is create a new `ServerStyleSheets`.\n\nWhen rendering, we will wrap `App`, our root component, inside a [`StylesProvider`](/styles/api/#stylesprovider) and [`ThemeProvider`](/styles/api/#themeprovider) to make the style configuration and the `theme` available to all components in the component tree.\n\nThe key step in server-side rendering is to render the initial HTML of our component **before** we send it to the client side. To do this, we use [ReactDOMServer.renderToString()](https://reactjs.org/docs/react-dom-server.html).\n\nWe then get the CSS from our `sheets` using `sheets.toString()`. We will see how this is passed along in our `renderFullPage` function.\n\n```jsx\nimport express from 'express';\nimport React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport { ServerStyleSheets, ThemeProvider } from '@material-ui/styles';\nimport App from './App';\nimport theme from './theme';\n\nfunction handleRender(req, res) {\n  const sheets = new ServerStyleSheets();\n\n  // Render the component to a string.\n  const html = ReactDOMServer.renderToString(\n    sheets.collect(\n      <ThemeProvider theme={theme}>\n        <App />\n      </ThemeProvider>,\n    ),\n  );\n\n  // Grab the CSS from our sheets.\n  const css = sheets.toString();\n\n  // Send the rendered page back to the client.\n  res.send(renderFullPage(html, css));\n}\n\nconst app = express();\n\napp.use('/build', express.static('build'));\n\n// This is fired every time the server-side receives a request.\napp.use(handleRender);\n\nconst port = 3000;\napp.listen(port);\n```\n\n### Inject Initial Component HTML and CSS\n\nThe final step on the server-side is to inject our initial component HTML and CSS into a template to be rendered on the client side.\n\n```js\nfunction renderFullPage(html, css) {\n  return `\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>My page</title>\n        <style id=\"jss-server-side\">${css}</style>\n      </head>\n      <body>\n        <div id=\"root\">${html}</div>\n      </body>\n    </html>\n  `;\n}\n```\n\n### Le côté client\n\nThe client side is straightforward. All we need to do is remove the server-side generated CSS. Let's take a look at our client file:\n\n`client.js`\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { ThemeProvider } from '@material-ui/styles';\nimport App from './App';\nimport theme from './theme';\n\nfunction Main() {\n  React.useEffect(() => {\n    const jssStyles = document.querySelector('#jss-server-side');\n    if (jssStyles) {\n      jssStyles.parentNode.removeChild(jssStyles);\n    }\n  }, []);\n\n  return (\n    <ThemeProvider theme={theme}>\n      <App />\n    </ThemeProvider>\n  );\n}\n\nReactDOM.hydrate(<Main />, document.querySelector('#root'));\n```\n\n## Implémentations de référence\n\nWe host different reference implementations which you can find in the [GitHub repository](https://github.com/mui-org/material-ui) under the [`/examples`](https://github.com/mui-org/material-ui/tree/master/examples) folder:\n\n- [The reference implementation of this tutorial](https://github.com/mui-org/material-ui/tree/master/examples/ssr)\n- [Gatsby](https://github.com/mui-org/material-ui/tree/master/examples/gatsby)\n- [Next.js](https://github.com/mui-org/material-ui/tree/master/examples/nextjs)\n\n## Résolution de problèmes\n\nCheck out our FAQ answer: [My App doesn't render correctly on the server](/getting-started/faq/#my-app-doesnt-render-correctly-on-the-server)."},tEUy:function(e,n,r){(window.__NEXT_P=window.__NEXT_P||[]).push(["/guides/server-rendering",function(){var e=r("aOOu");return{page:e.default||e}}])},uIbf:function(e,n){e.exports="# Renderizado en el servidor\n\n<p class=\"description\">The most common use case for server-side rendering is to handle the initial render when a user (or search engine crawler) first requests your app.</p>\n\nWhen the server receives the request, it renders the required component(s) into an HTML string, and then sends it as a response to the client. From that point on, the client takes over rendering duties.\n\n## Material-UI on the server\n\nMaterial-UI was designed from the ground-up with the constraint of rendering on the server, but it's up to you to make sure it's correctly integrated. It's important to provide the page with the required CSS, otherwise the page will render with just the HTML then wait for the CSS to be injected by the client, causing it to flicker (FOUC). To inject the style down to the client, we need to:\n\n1. Create a fresh, new [`ServerStyleSheets`](/styles/api/#serverstylesheets) instance on every request.\n2. Render the React tree with the server-side collector.\n3. Pull the CSS out.\n4. Pass the CSS along to the client.\n\nOn the client side, the CSS will be injected a second time before removing the server-side injected CSS.\n\n## Setting Up\n\nIn the following recipe, we are going to look at how to set up server-side rendering.\n\n### The theme\n\nWe create a theme that will be shared between the client and the server.\n\n`theme.js`\n\n```js\nimport { createMuiTheme } from '@material-ui/core/styles';\nimport red from '@material-ui/core/colors/red';\n\n// Create a theme instance.\nconst theme = createMuiTheme({\n  palette: {\n    primary: {\n      main: '#556cd6',\n    },\n    secondary: {\n      main: '#19857b',\n    },\n    error: {\n      main: red.A400,\n    },\n    background: {\n      default: '#fff',\n    },\n  },\n});\n\nexport default theme;\n```\n\n### The server-side\n\nThe following is the outline for what our server-side is going to look like. We are going to set up an [Express middleware](https://expressjs.com/en/guide/using-middleware.html) using [app.use](https://expressjs.com/en/api.html) to handle all requests that come in to our server. If you're unfamiliar with Express or middleware, just know that our handleRender function will be called every time the server receives a request.\n\n`server.js`\n\n```js\nimport express from 'express';\n\n// We are going to fill these out in the sections to follow.\nfunction renderFullPage(html, css) {\n  /* ... */\n}\n\nfunction handleRender(req, res) {\n  /* ... */\n}\n\nconst app = express();\n\n// Isso é acionado toda vez que o servidor recebe uma solicitação.\napp.use(handleRender);\n\nconst port = 3000;\napp.listen(port);\n```\n\n### Handling the Request\n\nThe first thing that we need to do on every request is create a new `ServerStyleSheets`.\n\nWhen rendering, we will wrap `App`, our root component, inside a [`StylesProvider`](/styles/api/#stylesprovider) and [`ThemeProvider`](/styles/api/#themeprovider) to make the style configuration and the `theme` available to all components in the component tree.\n\nThe key step in server-side rendering is to render the initial HTML of our component **before** we send it to the client side. To do this, we use [ReactDOMServer.renderToString()](https://reactjs.org/docs/react-dom-server.html).\n\nWe then get the CSS from our `sheets` using `sheets.toString()`. We will see how this is passed along in our `renderFullPage` function.\n\n```jsx\nimport express from 'express';\nimport React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport { ServerStyleSheets, ThemeProvider } from '@material-ui/styles';\nimport App from './App';\nimport theme from './theme';\n\nfunction handleRender(req, res) {\n  const sheets = new ServerStyleSheets();\n\n  // Render the component to a string.\n  const html = ReactDOMServer.renderToString(\n    sheets.collect(\n      <ThemeProvider theme={theme}>\n        <App />\n      </ThemeProvider>,\n    ),\n  );\n\n  // Grab the CSS from our sheets.\n  const css = sheets.toString();\n\n  // Send the rendered page back to the client.\n  res.send(renderFullPage(html, css));\n}\n\nconst app = express();\n\napp.use('/build', express.static('build'));\n\n// This is fired every time the server-side receives a request.\napp.use(handleRender);\n\nconst port = 3000;\napp.listen(port);\n```\n\n### Inject Initial Component HTML and CSS\n\nThe final step on the server-side is to inject our initial component HTML and CSS into a template to be rendered on the client side.\n\n```js\nfunction renderFullPage(html, css) {\n  return `\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>My page</title>\n        <style id=\"jss-server-side\">${css}</style>\n      </head>\n      <body>\n        <div id=\"root\">${html}</div>\n      </body>\n    </html>\n  `;\n}\n```\n\n### The Client Side\n\nThe client side is straightforward. All we need to do is remove the server-side generated CSS. Let's take a look at our client file:\n\n`client.js`\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { ThemeProvider } from '@material-ui/styles';\nimport App from './App';\nimport theme from './theme';\n\nfunction Main() {\n  React.useEffect(() => {\n    const jssStyles = document.querySelector('#jss-server-side');\n    if (jssStyles) {\n      jssStyles.parentNode.removeChild(jssStyles);\n    }\n  }, []);\n\n  return (\n    <ThemeProvider theme={theme}>\n      <App />\n    </ThemeProvider>\n  );\n}\n\nReactDOM.hydrate(<Main />, document.querySelector('#root'));\n```\n\n## Reference implementations\n\nWe host different reference implementations which you can find in the [GitHub repository](https://github.com/mui-org/material-ui) under the [`/examples`](https://github.com/mui-org/material-ui/tree/master/examples) folder:\n\n- [The reference implementation of this tutorial](https://github.com/mui-org/material-ui/tree/master/examples/ssr)\n- [Gatsby](https://github.com/mui-org/material-ui/tree/master/examples/gatsby)\n- [Next.js](https://github.com/mui-org/material-ui/tree/master/examples/nextjs)\n\n## Troubleshooting\n\nCheck out our FAQ answer: [My App doesn't render correctly on the server](/getting-started/faq/#my-app-doesnt-render-correctly-on-the-server)."}},[["tEUy","5d41","9da1"]]]);