(window.webpackJsonp=window.webpackJsonp||[]).push([["8611"],{"1NBc":function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/components/use-media-query",function(){var e=t("g6QI");return{page:e.default||e}}])},"8O2g":function(e,n){e.exports="import React from 'react';\nimport mediaQuery from 'css-mediaquery';\nimport { ThemeProvider } from '@material-ui/styles';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nfunction MyComponent() {\n  const matches = useMediaQuery('(min-width:600px)');\n\n  return <span>{`(min-width:600px) matches: ${matches}`}</span>;\n}\n\nexport default function ServerSide() {\n  const ssrMatchMedia = query => ({\n    // Use https://github.com/ericf/css-mediaquery as ponyfill.\n    matches: mediaQuery.match(query, {\n      // The estimated CSS width of the browser.\n      // For the sake of this demo, we are using a fixed value.\n      //\n      // In production, you can leverage:\n      //\n      // - Client hints. You can ask the client to send your server its width.\n      // Be aware that this feature is not supported everywhere: https://caniuse.com/#search=client%20hint.\n      // - User-agent. You can parse the user agent of the client, then convert the data to a\n      // is mobile or is desktop variable, and finally, guess the most likely screen width of the client.\n      width: 800,\n    }),\n  });\n\n  return (\n    <ThemeProvider\n      theme={{\n        props: {\n          MuiUseMediaQuery: { ssrMatchMedia },\n        },\n      }}\n    >\n      <MyComponent />\n    </ThemeProvider>\n  );\n}\n"},"9VWf":function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return s});var r=t("mXGw"),i=t.n(r),a=t("LHO+");function s(){var e=Object(a.a)("(min-width:600px)");return i.a.createElement("span",null,"(min-width:600px) matches: ".concat(e))}},"9tue":function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return d});var r=t("mXGw"),i=t.n(r),a=t("drO/"),s=t.n(a),o=t("LHO+");function d(){var e=Object(o.a)(s()({minWidth:600}));return i.a.createElement("span",null,"{ minWidth: 600 } matches: ".concat(e))}},CdTG:function(e,n){e.exports="---\ntitle: Media queries in React for responsive design\n---\n\n# useMediaQuery\n\n<p class=\"description\">This is a CSS media query hook for React. It listens for matches to a CSS media query. It allows the rendering of components based on whether the query matches or not.</p>\n\nSome of the key features:\n\n- âš›ï¸ It has an idiomatic React API.\n- ğŸš€ It's performant, it observes the document to detect when its media queries change, instead of polling the values periodically.\n- ğŸ“¦ [1 kB gzipped](/size-snapshot).\n- ğŸ¤– It supports server-side rendering.\n\n## Simple media query\n\nYou should provide a media query to the first argument of the hook. The media query string can by any valid CSS media query, e.g. `'print'`.\n\n{{\"demo\": \"pages/components/use-media-query/SimpleMediaQuery.js\", \"defaultCodeOpen\": true}}\n\n## Using Material-UI's breakpoint helpers\n\nYou can use Material-UI's [breakpoint helpers](/customization/breakpoints/) as follows:\n\n```jsx\nimport { useTheme } from '@material-ui/core/styles';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nfunction MyComponent() {\n  const theme = useTheme();\n  const matches = useMediaQuery(theme.breakpoints.up('sm'));\n\n  return <span>{`theme.breakpoints.up('sm') matches: ${matches}`}</span>;\n}\n```\n\n{{\"demo\": \"pages/components/use-media-query/ThemeHelper.js\"}}\n\nAlternatively, you can use a callback function, accepting the theme as a first argument:\n\n```jsx\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nfunction MyComponent() {\n  const matches = useMediaQuery(theme => theme.breakpoints.up('sm'));\n\n  return <span>{`theme.breakpoints.up('sm') matches: ${matches}`}</span>;\n}\n```\n\nâš ï¸ There is **no default** theme support, you have to inject it in a parent theme provider.\n\n## Using JavaScript syntax\n\nYou can use [json2mq](https://github.com/akiran/json2mq) to generate media query string from a JavaScript object.\n\n{{\"demo\": \"pages/components/use-media-query/JavaScriptMedia.js\", \"defaultCodeOpen\": true}}\n\n## Server-side rendering\n\nAn implementation of [matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) is required on the server. We recommend using [css-mediaquery](https://github.com/ericf/css-mediaquery) to emulate it.\n\n{{\"demo\": \"pages/components/use-media-query/ServerSide.js\"}}\n\nâš ï¸ Server-side rendering and client-side media queries are fundamentally at odds. Be aware of the tradeoff. The support can only be partial.\n\nTry relying on client-side CSS media queries first. For instance, you could use:\n\n- [`<Box display>`](/system/display/#hiding-elements)\n- [`<Hidden implementation=\"css\">`](/components/hidden/#css)\n- or [`themes.breakpoints.up(x)`](/customization/breakpoints/#css-media-queries)\n\n## Pruebas\n\nSimilar to the server-side case, you need an implementation of [matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) in your test environment.\n\nFor instance, [jsdom doesn't support it yet](https://github.com/jsdom/jsdom/blob/master/test/web-platform-tests/to-upstream/html/browsers/the-window-object/window-properties-dont-upstream.html). You should polyfill it. We recommend using [css-mediaquery](https://github.com/ericf/css-mediaquery) to emulate it.\n\n```js\nimport mediaQuery from 'css-mediaquery';\n\nfunction createMatchMedia(width) {\n  return query => ({\n    matches: mediaQuery.match(query, { width }),\n    addListener: () => {},\n    removeListener: () => {},\n  });\n}\n\ndescribe('MyTests', () => {\n  beforeAll(() => {\n    window.matchMedia = createMatchMedia(window.innerWidth);\n  });\n});\n```\n\n## Migrating from `withWidth()`\n\nThe `withWidth()` higher-order component injects the screen width of the page. You can reproduce the same behavior with a `useWidth` hook:\n\n{{\"demo\": \"pages/components/use-media-query/UseWidth.js\"}}\n\n## API\n\n### `useMediaQuery(query, [options]) => matches`\n\n#### Argumentos\n\n1. `query` (*String* | *Function*): A string representing the media query to handle or a callback function accepting the theme (in the context) that returns a string.\n2. `options` (*Object* [optional]): \n  - `options.defaultMatches` (*Boolean* [optional]): As `window.matchMedia()` is unavailable on the server, we return a default matches during the first mount. The default value is `false`.\n  - `options.noSsr` (*Boolean* [optional]): Defaults to `false`. In order to perform the server-side rendering reconciliation, it needs to render twice. A first time with nothing and a second time with the children. This double pass rendering cycle comes with a drawback. It's slower. You can set this flag to `true` if you are **not doing server-side rendering**.\n  - `options.ssrMatchMedia` (*Function* [optional]) You might want to use an heuristic to approximate the screen of the client browser. For instance, you could be using the user-agent or the client-hint https://caniuse.com/#search=client%20hint. You can provide a global ponyfill using [`custom props`](/customization/globals/#default-props) on the theme. Check the [server-side rendering example](#server-side-rendering).\n\n#### Devuelve\n\n`matches`: Matches is `true` if the document currently matches the media query and `false` when it does not.\n\n#### Ejemplos\n\n```jsx\nimport React from 'react';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nexport default function SimpleMediaQuery() {\n  const matches = useMediaQuery('print');\n\n  return <span>{`@media (min-width:600px) matches: ${matches}`}</span>;\n}\n```"},DvwJ:function(e,n,t){var r={"./JavaScriptMedia.js":"HRat","./JavaScriptMedia.tsx":"9tue","./ServerSide.js":"R8xx","./SimpleMediaQuery.js":"9VWf","./SimpleMediaQuery.tsx":"o++A","./ThemeHelper.js":"K++X","./ThemeHelper.tsx":"NHva","./UseWidth.js":"dKE/","./use-media-query-aa.md":"zqFt","./use-media-query-de.md":"ES1E","./use-media-query-es.md":"CdTG","./use-media-query-fr.md":"rAPh","./use-media-query-ja.md":"QLcj","./use-media-query-pt.md":"Q0+P","./use-media-query-ru.md":"pNoZ","./use-media-query-zh.md":"XeSz","./use-media-query.md":"HAdd"};function i(e){var n=a(e);return t(n)}function a(e){var n=r[e];if(!(n+1)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return n}i.keys=function(){return Object.keys(r)},i.resolve=a,e.exports=i,i.id="DvwJ"},ES1E:function(e,n){e.exports='---\ntitle: Medienanfragen in React fÃ¼r Responsive Design\n---\n\n# useMediaQuery\n\n<p class="description">Dies ist ein CSS-Media-Abfrage-Hook fÃ¼r React. Es wartet auf Ãœbereinstimmungen mit einer CSS-Medienabfrage. Es ermÃ¶glicht das Rendern von Komponenten basierend darauf, ob die Abfrage Ã¼bereinstimmt oder nicht.</p>\n\nEinige der wichtigsten Funktionen:\n\n- âš›ï¸ Es verfÃ¼gt Ã¼ber eine idiomatische React-API.\n- ğŸš€ Es ist performant. Es observiert das Dokument, welches erkennt, wenn sich die Medienabfragen Ã¤ndern, anstatt die Werte regelmÃ¤ÃŸig abzufragen.\n- ğŸ“¦ [ kB](/size-snapshot) gzipped.\n- ğŸ¤– It supports server-side rendering.\n\n## Einfache Medienabfrage\n\nSie sollten eine Medienabfrage fÃ¼r das erste Argument des Hooks bereitstellen. Die Medienabfragezeichenfolge kann durch jede gÃ¼ltige CSS-Medienabfrage erfolgen, z.B. `\'print\'`.\n\n{{"demo": "pages/components/use-media-query/SimpleMediaQuery.js", "defaultCodeOpen": true}}\n\n## Verwenden der Haltepunkt-Helfer der Material-UI\n\nSie kÃ¶nnen die Material-UI [Haltepunkt-Helfer](/customization/breakpoints/) wie folgt verwenden:\n\n```jsx\nimport { useTheme } from \'@material-ui/core/styles\';\nimport useMediaQuery from \'@material-ui/core/useMediaQuery\';\n\nfunction MyComponent() {\n  const theme = useTheme();\n  const matches = useMediaQuery(theme.breakpoints.up(\'sm\'));\n\n  return <span>{`theme.breakpoints.up(\'sm\') entspricht: ${matches}`}</span>;\n}\n```\n\n{{"demo": "pages/components/use-media-query/ThemeHelper.js"}}\n\nAlternatively, you can use a callback function, accepting the theme as a first argument:\n\n```jsx\nimport useMediaQuery from \'@material-ui/core/useMediaQuery\';\n\nfunction MyComponent() {\n  const matches = useMediaQuery(theme => theme.breakpoints.up(\'sm\'));\n\n  return <span>{`theme.breakpoints.up(\'sm\') matches: ${matches}`}</span>;\n}\n```\n\nâš ï¸ There is **no default** theme support, you have to inject it in a parent theme provider.\n\n## JavaScript-Syntax verwenden\n\nYou can use [json2mq](https://github.com/akiran/json2mq) to generate media query string from a JavaScript object.\n\n{{"demo": "pages/components/use-media-query/JavaScriptMedia.js", "defaultCodeOpen": true}}\n\n## Server-Rendering\n\nAn implementation of [matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) is required on the server. We recommend using [css-mediaquery](https://github.com/ericf/css-mediaquery) to emulate it.\n\n{{"demo": "pages/components/use-media-query/ServerSide.js"}}\n\nâš ï¸ Server-side rendering and client-side media queries are fundamentally at odds. Be aware of the tradeoff. The support can only be partial.\n\nTry relying on client-side CSS media queries first. For instance, you could use:\n\n- [`<Box display>`](/system/display/#hiding-elements)\n- [`<Hidden implementation="css">`](/components/hidden/#css)\n- or [`themes.breakpoints.up(x)`](/customization/breakpoints/#css-media-queries)\n\n## Testen\n\nSimilar to the server-side case, you need an implementation of [matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) in your test environment.\n\nFor instance, [jsdom doesn\'t support it yet](https://github.com/jsdom/jsdom/blob/master/test/web-platform-tests/to-upstream/html/browsers/the-window-object/window-properties-dont-upstream.html). You should polyfill it. We recommend using [css-mediaquery](https://github.com/ericf/css-mediaquery) to emulate it.\n\n```js\nimport mediaQuery from \'css-mediaquery\';\n\nfunction createMatchMedia(width) {\n  return query => ({\n    matches: mediaQuery.match(query, { width }),\n    addListener: () => {},\n    removeListener: () => {},\n  });\n}\n\ndescribe(\'MyTests\', () => {\n  beforeAll(() => {\n    window.matchMedia = createMatchMedia(window.innerWidth);\n  });\n});\n```\n\n## Migration von `withWidth()`\n\nDie Komponente hÃ¶herer Ordnung `withWidth()` fÃ¼gt die Bildschirmbreite der Seite ein. Sie kÃ¶nnen dasselbe Verhalten mit einem `useWidth` Hook reproduzieren:\n\n{{"demo": "pages/components/use-media-query/UseWidth.js"}}\n\n## API\n\n### `useMediaQuery(query, [options]) => matches`\n\n#### Argumente\n\n1. `query` (*String* | *Function*): A string representing the media query to handle or a callback function accepting the theme (in the context) that returns a string.\n2. `options` (*Object* [optional]): \n  - ` options.defaultMatches ` (*Boolean* [optional]): Da `window.matchMedia()` auf dem Server nicht verfÃ¼gbar ist, wird ein Standard Match zurÃ¼ckgegeben. Der Standardwert ist `false`.\n  - `options.noSsr ` (*Boolean* [optional]): Standardeinstellung ist `false`. Um den serverseitigen Renderingabgleich durchzufÃ¼hren, muss er zweimal gerendert werden. Ein erstes Mal mit nichts und ein zweites Mal mit den Kind-Elementen. Dieser Zyklus mit zwei DurchgÃ¤ngen ist mit einem Nachteil verbunden. Es ist langsamer. Sie kÃ¶nnen diese Flag auf `true` setzten, wenn Sie **nicht serverseitig** rendern.\n  - `options.ssrMatchMedia` (*Function* [optional]) Vielleicht mÃ¶chten Sie eine Heuristik verwenden, um annÃ¤hernd den Bildschirm des Client - Browser zu bestimmen. Sie kÃ¶nnten beispielsweise den Benutzeragenten oder den Client-Hinweis https://caniuse.com/#search=client%20hint verwenden. You can provide a global ponyfill using [`custom props`](/customization/globals/#default-props) on the theme. Lesen Sie hier mehr dazu: [serverseitige Rendering Beispiel](#server-side-rendering).\n\n#### RÃ¼ckgabewerte\n\n`matches`: Match ist `true` wenn das Dokument aktuell mit der Medienabfrage Ã¼bereinstimmt, und `false` wenn dies nicht der Fall ist.\n\n#### Beispiele\n\n```jsx\nimport React from \'react\';\nimport useMediaQuery from \'@material-ui/core/useMediaQuery\';\n\nexport default function SimpleMediaQuery() {\n  const matches = useMediaQuery(\'print\');\n\n  return <span>{`@media (min-width:600px) entspricht: ${matches}`}</span>;\n}\n```'},HAdd:function(e,n){e.exports="---\ntitle: Media queries in React for responsive design\n---\n\n# useMediaQuery\n\n<p class=\"description\">This is a CSS media query hook for React. It listens for matches to a CSS media query. It allows the rendering of components based on whether the query matches or not.</p>\n\nSome of the key features:\n\n- âš›ï¸ It has an idiomatic React API.\n- ğŸš€ It's performant, it observes the document to detect when its media queries change, instead of polling the values periodically.\n- ğŸ“¦ [1 kB gzipped](/size-snapshot).\n- ğŸ¤– It supports server-side rendering.\n\n## Simple media query\n\nYou should provide a media query to the first argument of the hook.\nThe media query string can by any valid CSS media query, e.g. `'print'`.\n\n{{\"demo\": \"pages/components/use-media-query/SimpleMediaQuery.js\", \"defaultCodeOpen\": true}}\n\n## Using Material-UI's breakpoint helpers\n\nYou can use Material-UI's [breakpoint helpers](/customization/breakpoints/) as follows:\n\n```jsx\nimport { useTheme } from '@material-ui/core/styles';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nfunction MyComponent() {\n  const theme = useTheme();\n  const matches = useMediaQuery(theme.breakpoints.up('sm'));\n\n  return <span>{`theme.breakpoints.up('sm') matches: ${matches}`}</span>;\n}\n```\n\n{{\"demo\": \"pages/components/use-media-query/ThemeHelper.js\"}}\n\nAlternatively, you can use a callback function, accepting the theme as a first argument:\n\n```jsx\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nfunction MyComponent() {\n  const matches = useMediaQuery(theme => theme.breakpoints.up('sm'));\n\n  return <span>{`theme.breakpoints.up('sm') matches: ${matches}`}</span>;\n}\n```\n\nâš ï¸ There is **no default** theme support, you have to inject it in a parent theme provider.\n\n## Using JavaScript syntax\n\nYou can use [json2mq](https://github.com/akiran/json2mq) to generate media query string from a JavaScript object.\n\n{{\"demo\": \"pages/components/use-media-query/JavaScriptMedia.js\", \"defaultCodeOpen\": true}}\n\n## Server-side rendering\n\nAn implementation of [matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) is required on the server.\nWe recommend using [css-mediaquery](https://github.com/ericf/css-mediaquery) to emulate it.\n\n{{\"demo\": \"pages/components/use-media-query/ServerSide.js\"}}\n\nâš ï¸ Server-side rendering and client-side media queries are fundamentally at odds.\nBe aware of the tradeoff. The support can only be partial.\n\nTry relying on client-side CSS media queries first.\nFor instance, you could use:\n\n- [`<Box display>`](/system/display/#hiding-elements)\n- [`<Hidden implementation=\"css\">`](/components/hidden/#css)\n- or [`themes.breakpoints.up(x)`](/customization/breakpoints/#css-media-queries)\n\n## Testing\n\nSimilar to the server-side case, you need an implementation of [matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) in your test environment.\n\nFor instance, [jsdom doesn't support it yet](https://github.com/jsdom/jsdom/blob/master/test/web-platform-tests/to-upstream/html/browsers/the-window-object/window-properties-dont-upstream.html). You should polyfill it.\nWe recommend using [css-mediaquery](https://github.com/ericf/css-mediaquery) to emulate it.\n\n```js\nimport mediaQuery from 'css-mediaquery';\n\nfunction createMatchMedia(width) {\n  return query => ({\n    matches: mediaQuery.match(query, { width }),\n    addListener: () => {},\n    removeListener: () => {},\n  });\n}\n\ndescribe('MyTests', () => {\n  beforeAll(() => {\n    window.matchMedia = createMatchMedia(window.innerWidth);\n  });\n});\n```\n\n## Migrating from `withWidth()`\n\nThe `withWidth()` higher-order component injects the screen width of the page.\nYou can reproduce the same behavior with a `useWidth` hook:\n\n{{\"demo\": \"pages/components/use-media-query/UseWidth.js\"}}\n\n## API\n\n### `useMediaQuery(query, [options]) => matches`\n\n#### Arguments\n\n1. `query` (*String* | *Function*): A string representing the media query to handle or a callback function accepting the theme (in the context) that returns a string.\n2. `options` (*Object* [optional]):\n  - `options.defaultMatches` (*Boolean* [optional]):\n  As `window.matchMedia()` is unavailable on the server,\n  we return a default matches during the first mount. The default value is `false`.\n  - `options.noSsr` (*Boolean* [optional]): Defaults to `false`.\n  In order to perform the server-side rendering reconciliation, it needs to render twice.\n  A first time with nothing and a second time with the children.\n  This double pass rendering cycle comes with a drawback. It's slower.\n  You can set this flag to `true` if you are **not doing server-side rendering**.\n  - `options.ssrMatchMedia` (*Function* [optional]) You might want to use an heuristic to approximate\n  the screen of the client browser.\n  For instance, you could be using the user-agent or the client-hint https://caniuse.com/#search=client%20hint.\n  You can provide a global ponyfill using [`custom props`](/customization/globals/#default-props) on the theme. Check the [server-side rendering example](#server-side-rendering).\n\n#### Returns\n\n`matches`: Matches is `true` if the document currently matches the media query and `false` when it does not.\n\n#### Examples\n\n```jsx\nimport React from 'react';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nexport default function SimpleMediaQuery() {\n  const matches = useMediaQuery('print');\n\n  return <span>{`@media (min-width:600px) matches: ${matches}`}</span>;\n}\n```\n"},HRat:function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return d});var r=t("mXGw"),i=t.n(r),a=t("drO/"),s=t.n(a),o=t("LHO+");function d(){var e=Object(o.a)(s()({minWidth:600}));return i.a.createElement("span",null,"{ minWidth: 600 } matches: ".concat(e))}},"K++X":function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return c});var r=t("mXGw"),i=t.n(r),a=t("LMpM"),s=t("mKyP"),o=t("h7Hf"),d=t("LHO+");var u=Object(s.a)(),m=i.a.createElement(o.a,{theme:u},i.a.createElement(function(){var e=Object(a.a)(),n=Object(d.a)(e.breakpoints.up("sm"));return i.a.createElement("span",null,"theme.breakpoints.up('sm') matches: ".concat(n))},null));function c(){return m}},NHva:function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return c});var r=t("mXGw"),i=t.n(r),a=t("LMpM"),s=t("mKyP"),o=t("h7Hf"),d=t("LHO+");var u=Object(s.a)(),m=i.a.createElement(o.a,{theme:u},i.a.createElement(function(){var e=Object(a.a)(),n=Object(d.a)(e.breakpoints.up("sm"));return i.a.createElement("span",null,"theme.breakpoints.up('sm') matches: ".concat(n))},null));function c(){return m}},"Q0+P":function(e,n){e.exports='---\ntitle: Consulta de mÃ­dia no React para design responsivo\n---\n\n# useMediaQuery\n\n<p class="description">Este Ã© um hook de CSS media query para React. Ele ouve correspondÃªncias para uma consulta de mÃ­dia no CSS. Permite a renderizaÃ§Ã£o de componentes com base no fato de a consulta corresponder ou nÃ£o.</p>\n\nAlgumas das principais caracterÃ­sticas:\n\n- âš›ï¸ Tem uma API React idiomÃ¡tica.\n- ğŸš€ Com desempenho, ele observa o documento para detectar quando suas consultas de mÃ­dia mudam, em vez de pesquisar os valores periodicamente.\n- ğŸ“¦ [1 kB gzipped](/size-snapshot).\n- ğŸ¤– Ele suporta a renderizaÃ§Ã£o do lado do servidor.\n\n## Consulta de mÃ­dia simples\n\nVocÃª deve fornecer uma consulta de mÃ­dia ao primeiro argumento do hook. A string de consulta de mÃ­dia pode ser feita por qualquer consulta de mÃ­dia CSS vÃ¡lida, por exemplo, `\'print\'`.\n\n{{"demo": "pages/components/use-media-query/SimpleMediaQuery.js", "defaultCodeOpen": true}}\n\n## Usando helpers de ponto de quebra do Material-UI\n\nVocÃª pode usar os [helpers de ponto de quebra](/customization/breakpoints/) do Material-UI da seguinte maneira:\n\n```jsx\nimport { useTheme } from \'@material-ui/core/styles\';\nimport useMediaQuery from \'@material-ui/core/useMediaQuery\';\n\nfunction MyComponent() {\n  const theme = useTheme();\n  const matches = useMediaQuery(theme.breakpoints.up(\'sm\'));\n\n  return <span>{`theme.breakpoints.up(\'sm\') matches: ${matches}`}</span>;\n}\n```\n\n{{"demo": "pages/components/use-media-query/ThemeHelper.js"}}\n\nComo alternativa, vocÃª pode usar uma funÃ§Ã£o de retorno de chamada, aceitando o tema como um primeiro argumento:\n\n```jsx\nimport useMediaQuery from \'@material-ui/core/useMediaQuery\';\n\nfunction MyComponent() {\n  const matches = useMediaQuery(theme => theme.breakpoints.up(\'sm\'));\n\n  return <span>{`theme.breakpoints.up(\'sm\') matches: ${matches}`}</span>;\n}\n```\n\nâš ï¸ NÃ£o hÃ¡ **nenhum suporte de tema padrÃ£o**, vocÃª precisa injetÃ¡-lo em um provedor de temas.\n\n## Usando a sintaxe JavaScript\n\nVocÃª pode usar [json2mq](https://github.com/akiran/json2mq) para gerar uma string de consulta de mÃ­dia a partir de um objeto JavaScript.\n\n{{"demo": "pages/components/use-media-query/JavaScriptMedia.js", "defaultCodeOpen": true}}\n\n## RenderizaÃ§Ã£o no servidor (Server-Side Rendering)\n\nUma implementaÃ§Ã£o de [matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) Ã© necessÃ¡ria no servidor. Recomendamos usar [css-mediaquery](https://github.com/ericf/css-mediaquery) para emulÃ¡-lo.\n\n{{"demo": "pages/components/use-media-query/ServerSide.js"}}\n\nâš ï¸ RenderizaÃ§Ã£o do lado servidor e consultas de mÃ­dia do lado cliente sÃ£o fundamentalmente conflitantes. Esteja ciente da troca. O suporte sÃ³ pode ser parcial.\n\nTente confiar em consultas de mÃ­dia CSS do lado do cliente primeiro. Por exemplo, vocÃª poderia usar:\n\n- [`<Box display>`](/system/display/#hiding-elements)\n- [`<Hidden implementation="css">`](/components/hidden/#css)\n- ou [`themes.breakpoints.up(x)`](/customization/breakpoints/#css-media-queries)\n\n## Testando\n\nSemelhante ao caso do lado do servidor, vocÃª precisa de uma implementaÃ§Ã£o de [matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) em seu ambiente de teste.\n\nPor exemplo, [jsdom nÃ£o suporta ainda](https://github.com/jsdom/jsdom/blob/master/test/web-platform-tests/to-upstream/html/browsers/the-window-object/window-properties-dont-upstream.html). VocÃª deve usar um polyfill para isso. Recomendamos usar [css-mediaquery](https://github.com/ericf/css-mediaquery) para emulÃ¡-lo.\n\n```js\nimport mediaQuery from \'css-mediaquery\';\n\nfunction createMatchMedia(width) {\n  return query => ({\n    matches: mediaQuery.match(query, { width }),\n    addListener: () => {},\n    removeListener: () => {},\n  });\n}\n\ndescribe(\'MeusTestes\', () => {\n  beforeAll(() => {\n    window.matchMedia = createMatchMedia(window.innerWidth);\n  });\n});\n```\n\n## Migrando de `withWidth()`\n\nO componente de ordem superior `withWidth()` injeta a largura da tela da pÃ¡gina. VocÃª pode reproduzir o mesmo comportamento com o hook `useWidth`:\n\n{{"demo": "pages/components/use-media-query/UseWidth.js"}}\n\n## API\n\n### `useMediaQuery(query, [options]) => matches`\n\n#### Argumentos\n\n1. `query` (*String* | *Function*): Uma string representando a consulta de mÃ­dia a ser manipulada ou uma funÃ§Ã£o de retorno de chamada aceitando o tema (no contexto) que retorna uma string.\n2. `options` (*Object* [opcional]): \n  - `options.defaultMatches` (*Boolean* [opcional]): Como `window.matchMedia()` nÃ£o esta disponÃ­vel no servidor, retornamos uma correspondÃªncia padrÃ£o durante a primeira montagem. O valor padrÃ£o Ã© `false`.\n  - `options.noSsr` (*Boolean* [opcional]): PadrÃ£o Ã© `false`. Para realizar a reconciliaÃ§Ã£o de renderizaÃ§Ã£o do lado do servidor, ele precisa renderizar duas vezes. Uma primeira vez sem nada e uma segunda vez com os filhos. Este ciclo de renderizaÃ§Ã£o de dupla passagem tem uma desvantagem. Ã‰ mais lento. VocÃª pode definir esse sinalizador para `true` se vocÃª **nÃ£o estiver fazendo a renderizaÃ§Ã£o do lado do servidor**.\n  - `options.ssrMatchMedia` (*Function* [opcional]) VocÃª pode querer usar uma heurÃ­stica para aproximar a tela no navegador do cliente. Por exemplo, vocÃª poderia estar usando o user-agent ou o client-hint https://caniuse.com/#search=client%20hint. VocÃª pode fornecer um global ponyfill usando [`propriedades customizadas`](/customization/globals/#default-props) no tema. Verifique o exemplo de renderizaÃ§Ã£o do lado do servidor [](#server-side-rendering).\n\n#### Retornos\n\n`matches`: Matches Ã© `true` se o documento coincidir com a consulta de mÃ­dia, e `false` quando isso nÃ£o ocorrer.\n\n#### Exemplos\n\n```jsx\nimport React from \'react\';\nimport useMediaQuery from \'@material-ui/core/useMediaQuery\';\n\nexport default function SimpleMediaQuery() {\n  const matches = useMediaQuery(\'print\');\n\n  return <span>{`@media (min-width:600px) matches: ${matches}`}</span>;\n}\n```'},QLcj:function(e,n){e.exports="---\ntitle: Media queries in React for responsive design\n---\n\n# useMediaQuery\n\n<p class=\"description\">This is a CSS media query hook for React. It listens for matches to a CSS media query. It allows the rendering of components based on whether the query matches or not.</p>\n\nSome of the key features:\n\n- âš›ï¸ It has an idiomatic React API.\n- ğŸš€ It's performant, it observes the document to detect when its media queries change, instead of polling the values periodically.\n- [1 kB gzipped](/size-snapshot).\n- serverã‚µãƒ¼ãƒãƒ¼å´ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚\n\n## Simple media query\n\nYou should provide a media query to the first argument of the hook. The media query string can by any valid CSS media query, e.g. `'print'`.\n\n{{\"demo\": \"pages/components/use-media-query/SimpleMediaQuery.js\", \"defaultCodeOpen\": true}}\n\n## Using Material-UI's breakpoint helpers\n\nYou can use Material-UI's [breakpoint helpers](/customization/breakpoints/) as follows:\n\n```jsx\nimport { useTheme } from '@material-ui/core/styles';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nfunction MyComponent() {\n  const theme = useTheme();\n  const matches = useMediaQuery(theme.breakpoints.up('sm'));\n\n  return <span>{`theme.breakpoints.up('sm') matches: ${matches}`}</span>;\n}\n```\n\n{{\"demo\": \"pages/components/use-media-query/ThemeHelper.js\"}}\n\nAlternatively, you can use a callback function, accepting the theme as a first argument:\n\n```jsx\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nfunction MyComponent() {\n  const matches = useMediaQuery(theme => theme.breakpoints.up('sm'));\n\n  return <span>{`theme.breakpoints.up('sm') matches: ${matches}`}</span>;\n}\n```\n\nâš ï¸ There is **no default** theme support, you have to inject it in a parent theme provider.\n\n## JavaScriptã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹\n\nYou can use [json2mq](https://github.com/akiran/json2mq) to generate media query string from a JavaScript object.\n\n{{\"demo\": \"pages/components/use-media-query/JavaScriptMedia.js\", \"defaultCodeOpen\": true}}\n\n## Server-side rendering\n\nAn implementation of [matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) is required on the server. We recommend using [css-mediaquery](https://github.com/ericf/css-mediaquery) to emulate it.\n\n{{\"demo\": \"pages/components/use-media-query/ServerSide.js\"}}\n\nâš ï¸ Server-side rendering and client-side media queries are fundamentally at odds. Be aware of the tradeoff. The support can only be partial.\n\nTry relying on client-side CSS media queries first. For instance, you could use:\n\n- [`<Box display>`](/system/display/#hiding-elements)\n- [`<Hidden implementation=\"css\">`](/components/hidden/#css)\n- or [`themes.breakpoints.up(x)`](/customization/breakpoints/#css-media-queries)\n\n## ãƒ†ã‚¹ãƒˆä¸­\n\nSimilar to the server-side case, you need an implementation of [matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) in your test environment.\n\nFor instance, [jsdom doesn't support it yet](https://github.com/jsdom/jsdom/blob/master/test/web-platform-tests/to-upstream/html/browsers/the-window-object/window-properties-dont-upstream.html). You should polyfill it. We recommend using [css-mediaquery](https://github.com/ericf/css-mediaquery) to emulate it.\n\n```js\nimport mediaQuery from 'css-mediaquery';\n\nfunction createMatchMedia(width) {\n  return query => ({\n    matches: mediaQuery.match(query, { width }),\n    addListener: () => {},\n    removeListener: () => {},\n  });\n}\n\ndescribe('MyTests', () => {\n  beforeAll(() => {\n    window.matchMedia = createMatchMedia(window.innerWidth);\n  });\n});\n```\n\n## Migrating from `withWidth()`\n\nThe `withWidth()` higher-order component injects the screen width of the page. You can reproduce the same behavior with a `useWidth` hook:\n\n{{\"demo\": \"pages/components/use-media-query/UseWidth.js\"}}\n\n## API\n\n### `useMediaQuery(query, [options]) => matches`\n\n#### å¼•æ•°\n\n1. `query` (*String* | *Function*): A string representing the media query to handle or a callback function accepting the theme (in the context) that returns a string.\n2. `ã‚ªãƒ—ã‚·ãƒ§ãƒ³` (*ã‚ªãƒ—ã‚¸ã‚§ã‚¯ãƒˆ* [ä»»æ„]): \n  - `options.defaultMatches` (*Boolean* [optional]): As `window.matchMedia()` is unavailable on the server, we return a default matches during the first mount. The default value is `false`.\n  - `options.noSsr` (*ãƒ–ãƒ¼ãƒ«å€¤* [ä»»æ„]): ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ `false`. In order to perform the server-side rendering reconciliation, it needs to render twice. A first time with nothing and a second time with the children. This double pass rendering cycle comes with a drawback. It's slower. You can set this flag to `true` if you are **not doing server-side rendering**.\n  - `options.ssrMatchMedia` (*Function* [optional]) You might want to use an heuristic to approximate the screen of the client browser. For instance, you could be using the user-agent or the client-hint https://caniuse.com/#search=client%20hint. You can provide a global ponyfill using [`custom props`](/customization/globals/#default-props) on the theme. Check the [server-side rendering example](#server-side-rendering).\n\n#### æˆ»ã‚Šå€¤\n\n`matches`: Matches is `true` if the document currently matches the media query and `false` when it does not.\n\n#### ä¾‹\n\n```jsx\nimport React from 'react';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nexport default function SimpleMediaQuery() {\n  const matches = useMediaQuery('print');\n\n  return <span>{`@media (min-width:600px) matches: ${matches}`}</span>;\n}\n```"},R0GA:function(e,n){e.exports="import React from 'react';\nimport { createMuiTheme, useTheme } from '@material-ui/core/styles';\nimport { ThemeProvider } from '@material-ui/styles';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nfunction MyComponent() {\n  const theme = useTheme();\n  const matches = useMediaQuery(theme.breakpoints.up('sm'));\n\n  return <span>{`theme.breakpoints.up('sm') matches: ${matches}`}</span>;\n}\n\nconst theme = createMuiTheme();\n\nexport default function ThemeHelper() {\n  return (\n    <ThemeProvider theme={theme}>\n      <MyComponent />\n    </ThemeProvider>\n  );\n}\n"},R8xx:function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return m});var r=t("mXGw"),i=t.n(r),a=t("lTUn"),s=t.n(a),o=t("h7Hf"),d=t("LHO+");var u=i.a.createElement(function(){var e=Object(d.a)("(min-width:600px)");return i.a.createElement("span",null,"(min-width:600px) matches: ".concat(e))},null);function m(){return i.a.createElement(o.a,{theme:{props:{MuiUseMediaQuery:{ssrMatchMedia:function(e){return{matches:s.a.match(e,{width:800})}}}}}},u)}},"TSH+":function(e,n,t){var r={"./JavaScriptMedia.js":"m+D3","./JavaScriptMedia.tsx":"oxla","./ServerSide.js":"8O2g","./SimpleMediaQuery.js":"Umxo","./SimpleMediaQuery.tsx":"z6cy","./ThemeHelper.js":"R0GA","./ThemeHelper.tsx":"VZYN","./UseWidth.js":"mw8F"};function i(e){var n=a(e);return t(n)}function a(e){var n=r[e];if(!(n+1)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return n}i.keys=function(){return Object.keys(r)},i.resolve=a,e.exports=i,i.id="TSH+"},Umxo:function(e,n){e.exports="import React from 'react';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nexport default function SimpleMediaQuery() {\n  const matches = useMediaQuery('(min-width:600px)');\n\n  return <span>{`(min-width:600px) matches: ${matches}`}</span>;\n}\n"},VZYN:function(e,n){e.exports="import React from 'react';\nimport { createMuiTheme, useTheme } from '@material-ui/core/styles';\nimport { ThemeProvider } from '@material-ui/styles';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nfunction MyComponent() {\n  const theme = useTheme();\n  const matches = useMediaQuery(theme.breakpoints.up('sm'));\n\n  return <span>{`theme.breakpoints.up('sm') matches: ${matches}`}</span>;\n}\n\nconst theme = createMuiTheme();\n\nexport default function ThemeHelper() {\n  return (\n    <ThemeProvider theme={theme}>\n      <MyComponent />\n    </ThemeProvider>\n  );\n}\n"},XeSz:function(e,n){e.exports="---\ntitle: Reactä¸­çš„åª’ä½“æŸ¥è¯¢ç”¨äºå“åº”å¼è®¾è®¡\n---\n\n# useMediaQuery\n\n<p class=\"description\">è¿™æ˜¯Reactçš„CSSåª’ä½“æŸ¥è¯¢é’©å­ã€‚ å®ƒä¾¦å¬ä¸CSSåª’ä½“æŸ¥è¯¢çš„åŒ¹é…ã€‚ å®ƒå…è®¸æ ¹æ®æŸ¥è¯¢æ˜¯å¦åŒ¹é…æ¥å‘ˆç°ç»„ä»¶ã€‚</p>\n\nä¸€äº›é‡è¦ç‰¹ç‚¹ï¼š\n\n- âš›ï¸å®ƒæœ‰ä¸€ä¸ªæƒ¯ç”¨çš„React APIã€‚\n- ğŸš€å®ƒå…·æœ‰é«˜æ€§èƒ½ï¼Œå®ƒä¼šè§‚å¯Ÿæ–‡æ¡£ä»¥æ£€æµ‹å…¶åª’ä½“æŸ¥è¯¢ä½•æ—¶å‘ç”Ÿæ›´æ”¹ï¼Œè€Œä¸æ˜¯å®šæœŸè½®è¯¢å€¼ã€‚\n- ğŸ“¦ [1 kB gzipped](/size-snapshot).\n- ğŸ¤– It supports server-side rendering.\n\n## ç®€å•çš„åª’ä½“æŸ¥è¯¢\n\næ‚¨åº”è¯¥ä¸ºæŒ‚é’©çš„ç¬¬ä¸€ä¸ªå‚æ•°æä¾›åª’ä½“æŸ¥è¯¢ã€‚ åª’ä½“æŸ¥è¯¢å­—ç¬¦ä¸²å¯ä»¥ç”±ä»»ä½•æœ‰æ•ˆçš„CSSåª’ä½“æŸ¥è¯¢ï¼Œå¦‚ `'print'`ã€‚\n\n{{\"demo\": \"pages/components/use-media-query/SimpleMediaQuery.js\", \"defaultCodeOpen\": true}}\n\n## ä½¿ç”¨Material-UIçš„æ–­ç‚¹åŠ©æ‰‹\n\nYou can use Material-UI's [breakpoint helpers](/customization/breakpoints/) as follows:\n\n```jsx\nimport { useTheme } from '@material-ui/core/styles';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nfunction MyComponent() {\n  const theme = useTheme();\n  const matches = useMediaQuery(theme.breakpoints.up('sm'));\n\n  return <span>{`theme.breakpoints.up('sm') matches: ${matches}`}</span>;\n}\n```\n\n{{\"demo\": \"pages/components/use-media-query/ThemeHelper.js\"}}\n\nAlternatively, you can use a callback function, accepting the theme as a first argument:\n\n```jsx\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nfunction MyComponent() {\n  const matches = useMediaQuery(theme => theme.breakpoints.up('sm'));\n\n  return <span>{`theme.breakpoints.up('sm') matches: ${matches}`}</span>;\n}\n```\n\nâš ï¸ There is **no default** theme support, you have to inject it in a parent theme provider.\n\n## ä½¿ç”¨JavaScriptè¯­æ³•\n\nYou can use [json2mq](https://github.com/akiran/json2mq) to generate media query string from a JavaScript object.\n\n{{\"demo\": \"pages/components/use-media-query/JavaScriptMedia.js\", \"defaultCodeOpen\": true}}\n\n## Server-side rendering\n\nAn implementation of [matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) is required on the server. We recommend using [css-mediaquery](https://github.com/ericf/css-mediaquery) to emulate it.\n\n{{\"demo\": \"pages/components/use-media-query/ServerSide.js\"}}\n\nâš ï¸ Server-side rendering and client-side media queries are fundamentally at odds. Be aware of the tradeoff. The support can only be partial.\n\nTry relying on client-side CSS media queries first. For instance, you could use:\n\n- [`<Box display>`](/system/display/#hiding-elements)\n- [`<Hidden implementation=\"css\">`](/components/hidden/#css)\n- or [`themes.breakpoints.up(x)`](/customization/breakpoints/#css-media-queries)\n\n## æµ‹è¯•\n\nSimilar to the server-side case, you need an implementation of [matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) in your test environment.\n\nFor instance, [jsdom doesn't support it yet](https://github.com/jsdom/jsdom/blob/master/test/web-platform-tests/to-upstream/html/browsers/the-window-object/window-properties-dont-upstream.html). You should polyfill it. We recommend using [css-mediaquery](https://github.com/ericf/css-mediaquery) to emulate it.\n\n```js\nimport mediaQuery from 'css-mediaquery';\n\nfunction createMatchMedia(width) {\n  return query => ({\n    matches: mediaQuery.match(query, { width }),\n    addListener: () => {},\n    removeListener: () => {},\n  });\n}\n\ndescribe('MyTests', () => {\n  beforeAll(() => {\n    window.matchMedia = createMatchMedia(window.innerWidth);\n  });\n});\n```\n\n## è¿å¾™è‡ª `withWidth()`\n\n`withWidth()` é«˜é˜¶ç»„ä»¶æ³¨å…¥é¡µé¢çš„å±å¹•å®½åº¦ã€‚ æ‚¨å¯ä»¥å¯¹ `useWidth` é’©å­é‡ç”¨ç›¸åŒçš„æ“ä½œï¼š\n\n{{\"demo\": \"pages/components/use-media-query/UseWidth.js\"}}\n\n## API\n\n### `useMediaQuery(query, [options]) => matches`\n\n#### å‚æ•°\n\n1. `query` (*String* | *Function*): A string representing the media query to handle or a callback function accepting the theme (in the context) that returns a string.\n2. `options` (*Object* [optional]): \n  - `options.defaultMatches` ï¼ˆ*å¸ƒå°”å€¼* [optional]ï¼‰ï¼š ä½œä¸º `window.matchMedia()` åœ¨æœåŠ¡å™¨ä¸Šä¸å¯ç”¨ï¼Œ æˆ‘ä»¬åœ¨ç¬¬ä¸€æ¬¡å®‰è£…æ—¶è¿”å›é»˜è®¤åŒ¹é…ã€‚ é»˜è®¤å€¼ä¸º `false`ã€‚\n  - `options.noSsr` (*Boolean* [å¯é€‰çš„]): é»˜è®¤å€¼ä¸º`false`ã€‚ ä¸ºäº†æ‰§è¡ŒæœåŠ¡å™¨ç«¯å‘ˆç°åè°ƒï¼Œå®ƒéœ€è¦å‘ˆç°ä¸¤æ¬¡ã€‚ ç¬¬ä¸€æ¬¡æ²¡æœ‰ä»»ä½•ä¸œè¥¿ï¼Œç¬¬äºŒæ¬¡ä¸å­©å­ä»¬åœ¨ä¸€èµ·ã€‚ è¿™ç§åŒéæ¸²æŸ“å‘¨æœŸæœ‰ä¸€ä¸ªç¼ºç‚¹ã€‚ å®ƒæ…¢äº†ã€‚ æ‚¨å¯ä»¥å°†æ­¤æ ‡å¿—è®¾ç½®ä¸º `çœŸ` ï¼Œå¦‚æœä½ æ˜¯ **æ²¡æœ‰åšæœåŠ¡å™¨ç«¯æ¸²æŸ“**ã€‚\n  - `options.ssrMatchMedia` ï¼ˆ*åŠŸèƒ½* [optional]ï¼‰æ‚¨å¯èƒ½å¸Œæœ›ä½¿ç”¨å¯å‘å¼æ¥è¿‘ä¼¼ å®¢æˆ·ç«¯æµè§ˆå™¨çš„å±å¹•ã€‚ ä¾‹å¦‚ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ç”¨æˆ·ä»£ç†æˆ–å®¢æˆ·ç«¯æç¤ºhttps://caniuse.com/#search=client%20hintã€‚ You can provide a global ponyfill using [`custom props`](/customization/globals/#default-props) on the theme. æ£€æŸ¥ [æœåŠ¡å™¨ç«¯å‘ˆç°ç¤ºä¾‹](#server-side-rendering)ã€‚\n\n#### è¿”å›ç»“æœ\n\n` matches `ï¼šå¦‚æœæ–‡æ¡£å½“å‰èƒ½å¤ŸåŒ¹é…è¿™ä¸ªåª’ä½“æŸ¥è¯¢ï¼ŒMatches æ˜¯ `true` ï¼Œå¦åˆ™ä¸º `false` ã€‚\n\n#### ä¾‹å­\n\n```jsx\nimport React from 'react';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nexport default function SimpleMediaQuery() {\n  const matches = useMediaQuery('print');\n\n  return <span>{`@media (min-width:600px) matches: ${matches}`}</span>;\n}\n```"},"dKE/":function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return p});var r=t("0tNF"),i=t("mXGw"),a=t.n(i),s=t("mii5"),o=t("h7Hf"),d=t("LHO+"),u=t("mKyP");var m=Object(u.a)(),c=a.a.createElement(o.a,{theme:m},a.a.createElement(function(){var e=function(){var e=Object(s.a)();return Object(r.default)(e.breakpoints.keys).reverse().reduce(function(n,t){var r=Object(d.a)(e.breakpoints.up(t));return!n&&r?t:n},null)||"xs"}();return a.a.createElement("span",null,"width: ".concat(e))},null));function p(){return c}},"drO/":function(e,n,t){var r=t("jFWS"),i=function(e){var n="",t=Object.keys(e);return t.forEach(function(i,a){var s=e[i];(function(e){return/[height|width]$/.test(e)})(i=r(i))&&"number"==typeof s&&(s+="px"),n+=!0===s?i:!1===s?"not "+i:"("+i+": "+s+")",a<t.length-1&&(n+=" and ")}),n};e.exports=function(e){var n="";return"string"==typeof e?e:e instanceof Array?(e.forEach(function(t,r){n+=i(t),r<e.length-1&&(n+=", ")}),n):i(e)}},g6QI:function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return u});var r=t("mXGw"),i=t.n(r),a=t("e+1t"),s=t("DvwJ"),o=t("TSH+"),d=i.a.createElement(a.a,{req:s,reqSource:o,reqPrefix:"pages/components/use-media-query"});function u(){return d}},jFWS:function(e,n){e.exports=function(e){return e.replace(/[A-Z]/g,function(e){return"-"+e.toLowerCase()}).toLowerCase()}},lTUn:function(e,n,t){"use strict";n.match=function(e,n){return d(e).some(function(e){var t=e.inverse,r="all"===e.type||n.type===e.type;if(r&&t||!r&&!t)return!1;var i=e.expressions.every(function(e){var t=e.feature,r=e.modifier,i=e.value,a=n[t];if(!a)return!1;switch(t){case"orientation":case"scan":return a.toLowerCase()===i.toLowerCase();case"width":case"height":case"device-width":case"device-height":i=c(i),a=c(a);break;case"resolution":i=m(i),a=m(a);break;case"aspect-ratio":case"device-aspect-ratio":case"device-pixel-ratio":i=u(i),a=u(a);break;case"grid":case"color":case"color-index":case"monochrome":i=parseInt(i,10)||1,a=parseInt(a,10)||0}switch(r){case"min":return a>=i;case"max":return a<=i;default:return a===i}});return i&&!t||!i&&t})},n.parse=d;var r=/(?:(only|not)?\s*([^\s\(\)]+)(?:\s*and)?\s*)?(.+)?/i,i=/\(\s*([^\s\:\)]+)\s*(?:\:\s*([^\s\)]+))?\s*\)/,a=/^(?:(min|max)-)?(.+)/,s=/(em|rem|px|cm|mm|in|pt|pc)?$/,o=/(dpi|dpcm|dppx)?$/;function d(e){return e.split(",").map(function(e){var n=(e=e.trim()).match(r),t=n[1],s=n[2],o=n[3]||"",d={};return d.inverse=!!t&&"not"===t.toLowerCase(),d.type=s?s.toLowerCase():"all",o=o.match(/\([^\)]+\)/g)||[],d.expressions=o.map(function(e){var n=e.match(i),t=n[1].toLowerCase().match(a);return{modifier:t[1],feature:t[2],value:n[2]}}),d})}function u(e){var n,t=Number(e);return t||(t=(n=e.match(/^(\d+)\s*\/\s*(\d+)$/))[1]/n[2]),t}function m(e){var n=parseFloat(e);switch(String(e).match(o)[1]){case"dpcm":return n/2.54;case"dppx":return 96*n;default:return n}}function c(e){var n=parseFloat(e);switch(String(e).match(s)[1]){case"em":case"rem":return 16*n;case"cm":return 96*n/2.54;case"mm":return 96*n/2.54/10;case"in":return 96*n;case"pt":return 72*n;case"pc":return 72*n/12;default:return n}}},"m+D3":function(e,n){e.exports="import React from 'react';\nimport json2mq from 'json2mq';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nexport default function JavaScriptMedia() {\n  const matches = useMediaQuery(\n    json2mq({\n      minWidth: 600,\n    }),\n  );\n\n  return <span>{`{ minWidth: 600 } matches: ${matches}`}</span>;\n}\n"},mw8F:function(e,n){e.exports="import React from 'react';\nimport { ThemeProvider, useTheme } from '@material-ui/styles';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\nimport { createMuiTheme } from '@material-ui/core/styles';\n\n/**\n * Be careful using this hook. It only works because the number of\n * breakpoints in theme is static. It will break once you change the number of\n * breakpoints. See https://reactjs.org/docs/hooks-rules.html#only-call-hooks-at-the-top-level\n */\nfunction useWidth() {\n  const theme = useTheme();\n  const keys = [...theme.breakpoints.keys].reverse();\n  return (\n    keys.reduce((output, key) => {\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      const matches = useMediaQuery(theme.breakpoints.up(key));\n      return !output && matches ? key : output;\n    }, null) || 'xs'\n  );\n}\n\nfunction MyComponent() {\n  const width = useWidth();\n  return <span>{`width: ${width}`}</span>;\n}\n\nconst theme = createMuiTheme();\n\nexport default function UseWidth() {\n  return (\n    <ThemeProvider theme={theme}>\n      <MyComponent />\n    </ThemeProvider>\n  );\n}\n"},"o++A":function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return s});var r=t("mXGw"),i=t.n(r),a=t("LHO+");function s(){var e=Object(a.a)("(min-width:600px)");return i.a.createElement("span",null,"(min-width:600px) matches: ".concat(e))}},oxla:function(e,n){e.exports="import React from 'react';\nimport json2mq from 'json2mq';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nexport default function JavaScriptMedia() {\n  const matches = useMediaQuery(\n    json2mq({\n      minWidth: 600,\n    }),\n  );\n\n  return <span>{`{ minWidth: 600 } matches: ${matches}`}</span>;\n}\n"},pNoZ:function(e,n){e.exports="---\ntitle: Consulta de mÃ­dia no React para design responsivo\n---\n\n# useMediaQuery\n\n<p class=\"description\">Ğ­Ñ‚Ğ¾ Ñ…ÑƒĞº Ğ¼ĞµĞ´Ğ¸Ğ°-Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ° CSS Ğ´Ğ»Ñ React. ĞĞ½ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚(ÑĞ»ÑƒÑˆĞ°ĞµÑ‚) ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ Ñ Ğ¼ĞµĞ´Ğ¸Ğ°-Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ¼ CSS. ĞĞ½ Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»ÑĞµÑ‚ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶Ğ°Ñ‚ÑŒ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹ Ğ² Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ Ñ‚Ğ¾Ğ³Ğ¾, ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ¸Ğ»Ğ¸ Ğ½ĞµÑ‚.</p>\n\nSome of the key features:\n\n- âš›ï¸ Ğ˜Ğ¼ĞµĞµÑ‚ Ğ¸Ğ´Ğ¸Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ React API.\n- ğŸš€ ĞĞ½ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ½. ĞĞ½ Ğ½Ğ°Ğ±Ğ»ÑĞ´Ğ°ĞµÑ‚ Ğ·Ğ° Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ¼, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ñ‚ÑŒ, ĞºĞ¾Ğ³Ğ´Ğ° ĞµĞ³Ğ¾ Ğ¼ĞµĞ´Ğ¸Ğ°-Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑ‹ Ğ¸Ğ·Ğ¼ĞµĞ½ÑÑÑ‚ÑÑ, Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Ğ¿ĞµÑ€Ğ¸Ğ¾Ğ´Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ³Ğ¾ Ğ¾Ğ¿Ñ€Ğ¾ÑĞ° Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ.\n- 1 [1 ĞºĞ‘ Ğ² ÑĞ¶Ğ°Ñ‚Ğ¾Ğ¼ Ğ²Ğ¸Ğ´Ğµ](/size-snapshot).\n- ğŸ¤– It supports server-side rendering.\n\n## ĞŸÑ€Ğ¾ÑÑ‚Ğ¾Ğ¹ Ğ¼ĞµĞ´Ğ¸Ğ°-Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ\n\nĞ’Ñ‹ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¼ĞµĞ´Ğ¸Ğ°-Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑƒ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚ Ñ…ÑƒĞºĞ°. Ğ¡Ñ‚Ñ€Ğ¾ĞºĞ° Ğ¼ĞµĞ´Ğ¸Ğ°-Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ° Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ğ»ÑĞ±Ñ‹Ğ¼ Ğ´Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ñ‹Ğ¼ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸ĞµĞ¼ Ğ¼ĞµĞ´Ğ¸Ğ°-Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ¼ CSS, Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, `'print'`.\n\n{{\"demo\": \"pages/components/use-media-query/SimpleMediaQuery.js\", \"defaultCodeOpen\": true}}\n\n## Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ½Ğ¸ĞºĞ¾Ğ² Ñ‚Ğ¾Ñ‡ĞµĞº Ğ¿ĞµÑ€ĞµĞ»Ğ¾Ğ¼Ğ° Material-UI\n\nĞ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ [Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ½Ğ¸ĞºĞ¾Ğ² Ñ‚Ğ¾Ñ‡ĞµĞº Ğ¿ĞµÑ€ĞµĞ»Ğ¾Ğ¼Ğ° Material-UI](/customization/breakpoints/) ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¼ Ğ¾Ğ±Ñ€Ğ°Ğ·Ğ¾Ğ¼:\n\n```jsx\nimport { useTheme } from '@material-ui/core/styles';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nfunction MyComponent() {\n  const theme = useTheme();\n  const matches = useMediaQuery(theme.breakpoints.up('sm'));\n\n  return <span>{`theme.breakpoints.up('sm') matches: ${matches}`}</span>;\n}\n```\n\n{{\"demo\": \"pages/components/use-media-query/ThemeHelper.js\"}}\n\nAlternatively, you can use a callback function, accepting the theme as a first argument:\n\n```jsx\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nfunction MyComponent() {\n  const matches = useMediaQuery(theme => theme.breakpoints.up('sm'));\n\n  return <span>{`theme.breakpoints.up('sm') matches: ${matches}`}</span>;\n}\n```\n\nâš ï¸ There is **no default** theme support, you have to inject it in a parent theme provider.\n\n## Using JavaScript syntax\n\nYou can use [json2mq](https://github.com/akiran/json2mq) to generate media query string from a JavaScript object.\n\n{{\"demo\": \"pages/components/use-media-query/JavaScriptMedia.js\", \"defaultCodeOpen\": true}}\n\n## Server-side rendering\n\nAn implementation of [matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) is required on the server. We recommend using [css-mediaquery](https://github.com/ericf/css-mediaquery) to emulate it.\n\n{{\"demo\": \"pages/components/use-media-query/ServerSide.js\"}}\n\nâš ï¸ Server-side rendering and client-side media queries are fundamentally at odds. Be aware of the tradeoff. The support can only be partial.\n\nTry relying on client-side CSS media queries first. For instance, you could use:\n\n- [`<Box display>`](/system/display/#hiding-elements)\n- [`<Hidden implementation=\"css\">`](/components/hidden/#css)\n- or [`themes.breakpoints.up(x)`](/customization/breakpoints/#css-media-queries)\n\n## Ğ¢ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ\n\nSimilar to the server-side case, you need an implementation of [matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) in your test environment.\n\nFor instance, [jsdom doesn't support it yet](https://github.com/jsdom/jsdom/blob/master/test/web-platform-tests/to-upstream/html/browsers/the-window-object/window-properties-dont-upstream.html). You should polyfill it. We recommend using [css-mediaquery](https://github.com/ericf/css-mediaquery) to emulate it.\n\n```js\nimport mediaQuery from 'css-mediaquery';\n\nfunction createMatchMedia(width) {\n  return query => ({\n    matches: mediaQuery.match(query, { width }),\n    addListener: () => {},\n    removeListener: () => {},\n  });\n}\n\ndescribe('MyTests', () => {\n  beforeAll(() => {\n    window.matchMedia = createMatchMedia(window.innerWidth);\n  });\n});\n```\n\n## Migrating from `withWidth()`\n\nThe `withWidth()` higher-order component injects the screen width of the page. You can reproduce the same behavior with a `useWidth` hook:\n\n{{\"demo\": \"pages/components/use-media-query/UseWidth.js\"}}\n\n## API\n\n### `useMediaQuery(query, [options]) => matches`\n\n#### ĞÑ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚Ñ‹\n\n1. `query` (*String* | *Function*): A string representing the media query to handle or a callback function accepting the theme (in the context) that returns a string.\n2. `options` (*Object* [optional]): \n  - `options.defaultMatches` (*Boolean* [optional]): As `window.matchMedia()` is unavailable on the server, we return a default matches during the first mount. The default value is `false`.\n  - `options.noSsr` (*Boolean* [optional]): Defaults to `false`. In order to perform the server-side rendering reconciliation, it needs to render twice. A first time with nothing and a second time with the children. This double pass rendering cycle comes with a drawback. It's slower. You can set this flag to `true` if you are **not doing server-side rendering**.\n  - `options.ssrMatchMedia` (*Function* [optional]) You might want to use an heuristic to approximate the screen of the client browser. For instance, you could be using the user-agent or the client-hint https://caniuse.com/#search=client%20hint. You can provide a global ponyfill using [`custom props`](/customization/globals/#default-props) on the theme. Check the [server-side rendering example](#server-side-rendering).\n\n#### Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚\n\n`matches`: Matches is `true` if the document currently matches the media query and `false` when it does not.\n\n#### ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹\n\n```jsx\nimport React from 'react';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nexport default function SimpleMediaQuery() {\n  const matches = useMediaQuery('print');\n\n  return <span>{`@media (min-width:600px) matches: ${matches}`}</span>;\n}\n```"},rAPh:function(e,n){e.exports="---\ntitle: Media queries in React for responsive design\n---\n\n# useMediaQuery\n\n<p class=\"description\">This is a CSS media query hook for React. It listens for matches to a CSS media query. It allows the rendering of components based on whether the query matches or not.</p>\n\nSome of the key features:\n\n- âš›ï¸ It has an idiomatic React API.\n- ğŸš€ It's performant, it observes the document to detect when its media queries change, instead of polling the values periodically.\n- ğŸ“¦ [1 kB gzipped](/size-snapshot).\n- ğŸ¤– It supports server-side rendering.\n\n## Simple media query\n\nYou should provide a media query to the first argument of the hook. The media query string can by any valid CSS media query, e.g. `'print'`.\n\n{{\"demo\": \"pages/components/use-media-query/SimpleMediaQuery.js\", \"defaultCodeOpen\": true}}\n\n## Using Material-UI's breakpoint helpers\n\nYou can use Material-UI's [breakpoint helpers](/customization/breakpoints/) as follows:\n\n```jsx\nimport { useTheme } from '@material-ui/core/styles';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nfunction MyComponent() {\n  const theme = useTheme();\n  const matches = useMediaQuery(theme.breakpoints.up('sm'));\n\n  return <span>{`theme.breakpoints.up('sm') matches: ${matches}`}</span>;\n}\n```\n\n{{\"demo\": \"pages/components/use-media-query/ThemeHelper.js\"}}\n\nAlternatively, you can use a callback function, accepting the theme as a first argument:\n\n```jsx\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nfunction MyComponent() {\n  const matches = useMediaQuery(theme => theme.breakpoints.up('sm'));\n\n  return <span>{`theme.breakpoints.up('sm') matches: ${matches}`}</span>;\n}\n```\n\nâš ï¸ There is **no default** theme support, you have to inject it in a parent theme provider.\n\n## Using JavaScript syntax\n\nYou can use [json2mq](https://github.com/akiran/json2mq) to generate media query string from a JavaScript object.\n\n{{\"demo\": \"pages/components/use-media-query/JavaScriptMedia.js\", \"defaultCodeOpen\": true}}\n\n## Server-side rendering\n\nAn implementation of [matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) is required on the server. We recommend using [css-mediaquery](https://github.com/ericf/css-mediaquery) to emulate it.\n\n{{\"demo\": \"pages/components/use-media-query/ServerSide.js\"}}\n\nâš ï¸ Server-side rendering and client-side media queries are fundamentally at odds. Be aware of the tradeoff. The support can only be partial.\n\nTry relying on client-side CSS media queries first. For instance, you could use:\n\n- [`<Box display>`](/system/display/#hiding-elements)\n- [`<Hidden implementation=\"css\">`](/components/hidden/#css)\n- or [`themes.breakpoints.up(x)`](/customization/breakpoints/#css-media-queries)\n\n## Test\n\nSimilar to the server-side case, you need an implementation of [matchMedia](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) in your test environment.\n\nFor instance, [jsdom doesn't support it yet](https://github.com/jsdom/jsdom/blob/master/test/web-platform-tests/to-upstream/html/browsers/the-window-object/window-properties-dont-upstream.html). You should polyfill it. We recommend using [css-mediaquery](https://github.com/ericf/css-mediaquery) to emulate it.\n\n```js\nimport mediaQuery from 'css-mediaquery';\n\nfunction createMatchMedia(width) {\n  return query => ({\n    matches: mediaQuery.match(query, { width }),\n    addListener: () => {},\n    removeListener: () => {},\n  });\n}\n\ndescribe('MyTests', () => {\n  beforeAll(() => {\n    window.matchMedia = createMatchMedia(window.innerWidth);\n  });\n});\n```\n\n## Migrating from `withWidth()`\n\nThe `withWidth()` higher-order component injects the screen width of the page. You can reproduce the same behavior with a `useWidth` hook:\n\n{{\"demo\": \"pages/components/use-media-query/UseWidth.js\"}}\n\n## API\n\n### `useMediaQuery(query, [options]) => matches`\n\n#### ParamÃ¨tres\n\n1. `query` (*String* | *Function*): A string representing the media query to handle or a callback function accepting the theme (in the context) that returns a string.\n2. `options` (*Object* [optional]): \n  - `options.defaultMatches` (*Boolean* [optional]): As `window.matchMedia()` is unavailable on the server, we return a default matches during the first mount. The default value is `false`.\n  - `options.noSsr` (*Boolean* [optional]): Valeur par dÃ©faut `false`. In order to perform the server-side rendering reconciliation, it needs to render twice. A first time with nothing and a second time with the children. This double pass rendering cycle comes with a drawback. It's slower. You can set this flag to `true` if you are **not doing server-side rendering**.\n  - `options.ssrMatchMedia` (*Function* [optional]) You might want to use an heuristic to approximate the screen of the client browser. For instance, you could be using the user-agent or the client-hint https://caniuse.com/#search=client%20hint. You can provide a global ponyfill using [`custom props`](/customization/globals/#default-props) on the theme. Check the [server-side rendering example](#server-side-rendering).\n\n#### Valeur de retour\n\n`matches`: Matches is `true` if the document currently matches the media query and `false` when it does not.\n\n#### Exemples\n\n```jsx\nimport React from 'react';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nexport default function SimpleMediaQuery() {\n  const matches = useMediaQuery('print');\n\n  return <span>{`@media (min-width:600px) matches: ${matches}`}</span>;\n}\n```"},z6cy:function(e,n){e.exports="import React from 'react';\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\n\nexport default function SimpleMediaQuery() {\n  const matches = useMediaQuery('(min-width:600px)');\n\n  return <span>{`(min-width:600px) matches: ${matches}`}</span>;\n}\n"},zqFt:function(e,n){e.exports='---\ntitle: crwdns92704:0crwdne92704:0\n---\n\n# crwdns92706:0crwdne92706:0\n\n<p class="description">crwdns92708:0crwdne92708:0 crwdns92710:0crwdne92710:0 crwdns92712:0crwdne92712:0</p>\n\ncrwdns92714:0crwdne92714:0\n\n- crwdns92716:0crwdne92716:0\n- crwdns92718:0crwdne92718:0\n- crwdns92720:0crwdne92720:0\n- crwdns92722:0crwdne92722:0\n\n## crwdns92724:0crwdne92724:0\n\ncrwdns92726:0crwdne92726:0 crwdns92728:0crwdne92728:0\n\ncrwdns92730:0crwdne92730:0\n\n## crwdns92732:0crwdne92732:0\n\ncrwdns92734:0crwdne92734:0\n\n```jsx\ncrwdns92736:0{ useTheme }crwdnd92736:0${matches}crwdne92736:0\n```\n\ncrwdns92738:0crwdne92738:0\n\ncrwdns92740:0crwdne92740:0\n\n```jsx\ncrwdns92742:0${matches}crwdne92742:0\n```\n\ncrwdns92744:0crwdne92744:0\n\n## crwdns92746:0crwdne92746:0\n\ncrwdns92748:0crwdne92748:0\n\ncrwdns92750:0crwdne92750:0\n\n## crwdns92752:0crwdne92752:0\n\ncrwdns92754:0crwdne92754:0 crwdns92756:0crwdne92756:0\n\ncrwdns92758:0crwdne92758:0\n\ncrwdns92760:0crwdne92760:0 crwdns92762:0crwdne92762:0 crwdns92764:0crwdne92764:0\n\ncrwdns92766:0crwdne92766:0 crwdns92768:0crwdne92768:0\n\n- [`crwdns92772:0crwdne92772:0`](crwdns92770:0crwdne92770:0)\n- [`crwdns92776:0crwdne92776:0`](crwdns92774:0crwdne92774:0)\n- crwdns92778:0crwdne92778:0\n\n## crwdns92780:0crwdne92780:0\n\ncrwdns92782:0crwdne92782:0\n\ncrwdns92784:0crwdne92784:0 crwdns92786:0crwdne92786:0 crwdns92788:0crwdne92788:0\n\n```js\ncrwdns92790:0{ width }crwdne92790:0\n```\n\n## crwdns92792:0crwdne92792:0\n\ncrwdns92794:0crwdne92794:0 crwdns92796:0crwdne92796:0\n\ncrwdns92798:0crwdne92798:0\n\n## crwdns92800:0crwdne92800:0\n\n### `crwdns92802:0[options]crwdne92802:0`\n\n#### crwdns92804:0crwdne92804:0\n\n1. crwdns92806:0crwdne92806:0\n2. crwdns92808:0[optional]crwdne92808:0 \n  - crwdns92810:0[optional]crwdne92810:0 crwdns92812:0crwdne92812:0\n  - crwdns92814:0[optional]crwdne92814:0 crwdns92816:0crwdne92816:0 crwdns92818:0crwdne92818:0 crwdns92820:0crwdne92820:0 crwdns92822:0crwdne92822:0 crwdns92824:0crwdne92824:0\n  - crwdns92826:0[optional]crwdne92826:0 crwdns92828:0%20hicrwdne92828:0 crwdns92830:0crwdne92830:0 crwdns92832:0crwdne92832:0\n\n#### crwdns92834:0crwdne92834:0\n\ncrwdns92836:0crwdne92836:0\n\n#### crwdns92838:0crwdne92838:0\n\n```jsx\ncrwdns92840:0${matches}crwdne92840:0\n```'}},[["1NBc","5d41","9da1"]]]);